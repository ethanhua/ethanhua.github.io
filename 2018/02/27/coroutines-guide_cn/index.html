<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.4.0 -->
    <script>window.materialVersion = "1.4.0"</script>

    <!-- Title -->
    
    <title>
        
            Kotlin协程入门指南（译文） | 
        
        Ethanhua&#39;s blog
    </title>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">
    
    
    
    
    
    
    
    
    
    

    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="Ethan Hua">
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content="blog,Kotlin">

    <!-- Site Verification -->
    
    

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/avatar.jpg">
    <link rel="icon" sizes="192x192" href="/img/avatar.jpg">
    <link rel="apple-touch-icon" href="/img/avatar.jpg">

    <!--iOS -->
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Ethanhua&#39;s blog">

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Kotlin协程入门指南（译文） | Ethanhua&#39;s blog">
    <meta property="og:image" content="/img/avatar.jpg" />
    <meta property="og:description" content="">
    <meta property="og:article:tag" content="Kotlin"> 

    
        <meta property="article:published_time" content="2月 27, 2018" />
        <meta property="article:modified_time" content="4月 01, 2018" />
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:title" content="Kotlin协程入门指南（译文） | Ethanhua&#39;s blog">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/img/avatar.jpg">
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="http://yoursite.com" />

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://yoursite.com/2018/02/27/coroutines-guide_cn/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Ethanhua&#39;s blog",
        "logo": "/img/avatar.jpg"
    },
    "author": {
        "@type": "Person",
        "name": "Ethan Hua",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.jpg"
        },
        "description": "keep calm and be happy :)"
    },
    "headline": "Kotlin协程入门指南（译文）",
    "url": "http://yoursite.com/2018/02/27/coroutines-guide_cn/index.html",
    "datePublished": "2月 27, 2018",
    "dateModified": "4月 01, 2018",
    "description": "",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://yoursite.com"
    }
}
</script>


    

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(key){try{localStorage.removeItem(key)}catch(e){}};lsloader.setLS=function(key,val){try{localStorage.setItem(key,val)}catch(e){}};lsloader.getLS=function(key){var val="";try{val=localStorage.getItem(key)}catch(e){val=""}return val};versionString="/*"+materialVersion+"*/";lsloader.clean=function(){try{var keys=[];for(var i=0;i<localStorage.length;i++){keys.push(localStorage.key(i))}keys.forEach(function(key){var data=lsloader.getLS(key);if(data&&data.indexOf(versionString)===-1){lsloader.removeLS(key)}})}catch(e){}};lsloader.clean();lsloader.load=function(jsname,jspath,cssonload){cssonload=cssonload||function(){};var code;code=this.getLS(jsname);if(code&&code.indexOf(versionString)===-1){this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload);return}if(code){var versionNumber=code.split(versionString)[0];if(versionNumber!=jspath){console.log("reload:"+jspath);this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload);return}code=code.split(versionString)[1];if(/\.js?.+$/.test(versionNumber)){this.jsRunSequence.push({name:jsname,code:code});this.runjs(jspath,jsname,code)}else{document.getElementById(jsname).appendChild(document.createTextNode(code));cssonload()}}else{this.requestResource(jsname,jspath,cssonload)}};lsloader.requestResource=function(name,path,cssonload){var that=this;if(/\.js?.+$/.test(path)){this.iojs(path,name,function(path,name,code){that.setLS(name,path+versionString+code);that.runjs(path,name,code)})}else if(/\.css?.+$/.test(path)){this.iocss(path,name,function(code){document.getElementById(name).appendChild(document.createTextNode(code));that.setLS(name,path+versionString+code)},cssonload)}};lsloader.iojs=function(path,jsname,callback){var that=this;that.jsRunSequence.push({name:jsname,code:""});try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(path,jsname,xhr.response);return}}that.jsfallback(path,jsname)}};xhr.send(null)}catch(e){that.jsfallback(path,jsname)}};lsloader.iocss=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.iofonts=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.runjs=function(path,name,code){if(!!name&&!!code){for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code=code}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var script=document.createElement("script");script.appendChild(document.createTextNode(this.jsRunSequence[0].code));script.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(script);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var that=this;var script=document.createElement("script");script.src=this.jsRunSequence[0].path;script.type="text/javascript";this.jsRunSequence[0].status="loading";script.onload=function(){that.jsRunSequence.shift();if(that.jsRunSequence.length>0){that.runjs()}};document.body.appendChild(script)}};lsloader.tagLoad=function(path,name){this.jsRunSequence.push({name:name,code:"",path:path,status:"failed"});this.runjs()};lsloader.jsfallback=function(path,name){if(!!this.jsnamemap[name]){return}else{this.jsnamemap[name]=name}for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code="";this.jsRunSequence[k].status="failed";this.jsRunSequence[k].path=path}}this.runjs()};lsloader.cssfallback=function(path,name,cssonload){if(!!this.cssnamemap[name]){return}else{this.cssnamemap[name]=1}var link=document.createElement("link");link.type="text/css";link.href=path;link.rel="stylesheet";link.onload=link.onerror=cssonload;var root=document.getElementsByTagName("script")[0];root.parentNode.insertBefore(link,root)};lsloader.runInlineScript=function(scriptId,codeId){var code=document.getElementById(codeId).innerText;this.jsRunSequence.push({name:scriptId,code:code});this.runjs()};lsloader.loadCombo=function(jslist){var updateList="";var requestingModules={};for(var k in jslist){var LS=this.getLS(jslist[k].name);if(!!LS){var version=LS.split(versionString)[0];var code=LS.split(versionString)[1]}else{var version=""}if(version==jslist[k].path){this.jsRunSequence.push({name:jslist[k].name,code:code,path:jslist[k].path})}else{this.jsRunSequence.push({name:jslist[k].name,code:null,path:jslist[k].path,status:"comboloading"});requestingModules[jslist[k].name]=true;updateList+=(updateList==""?"":";")+jslist[k].path}}var that=this;if(!!updateList){var xhr=new XMLHttpRequest;xhr.open("get",combo+updateList,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){that.runCombo(xhr.response,requestingModules);return}}else{for(var i in that.jsRunSequence){if(requestingModules[that.jsRunSequence[i].name]){that.jsRunSequence[i].status="failed"}}that.runjs()}}};xhr.send(null)}this.runjs()};lsloader.runCombo=function(comboCode,requestingModules){comboCode=comboCode.split("/*combojs*/");comboCode.shift();for(var k in this.jsRunSequence){if(!!requestingModules[this.jsRunSequence[k].name]&&!!comboCode[0]){this.jsRunSequence[k].status="comboJS";this.jsRunSequence[k].code=comboCode[0];this.setLS(this.jsRunSequence[k].name,this.jsRunSequence[k].path+versionString+comboCode[0]);comboCode.shift()}}this.runjs()}})();</script>

    <!-- Import CSS & jQuery -->
    
        <style id="css/material.min.css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("css/material.min.css","/css/material.min.css?fJTiM/K1J3dWIruo3pxtAw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";})</script>
        <style id="css/style.min.css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("css/style.min.css","/css/style.min.css?oCSEO3ST+aEypEwttTDI9g==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";})</script>
        
        
            <style>
    
    
    
    
    
    
    
    .footer-sns-github {
        background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPjxwYXRoIGQ9Ik0xMzguNCA3OGMtNi40IDEuNC0yNi40IDE0LjItMzYgMjIuOC04IDcuMi0yMiAyOS44LTI0LjQgMzkuMi0xLjYgNi40LTIgMTEzLjItMS42IDM2OCAuNiAyOTkuNCAxIDM1OS44IDMuNCAzNjQgMTEgMjAuMiAyMS42IDMyLjQgMzcuMiA0MyAxNS42IDEwLjYgMTcuMiAxMS4yIDM0LjIgMTMuMiAxMC42IDEuMiA2My40IDEuNiAxMjcuNiAxLjRsMTA5LjYtLjYgNi02LjggNi4yLTYuOC0xLjItMjUuMmMtLjgtMTUuOC0uMi0zMy40IDEuNC00Ny4yIDMtMjUuNCAxLjQtMzYuMi02LTQzLjItNS00LjYtNi4yLTQuOC0zMC42LTQuMi0yNy42LjgtMjQgMS42LTY4LjgtMTYtOC42LTMuNC0yMi42LTE4LTI4LjQtMjkuOC0xMS40LTIyLjgtMjctNDUtMzkuMi01NS42LTE0LTEyLjItMTkuOC0yMC44LTE5LjgtMjguNiAwLTExLjYgMTMuNi0xMi42IDMzLjItMi40IDE2LjYgOC44IDIwLjggMTIuNCA0MC44IDM2LjIgMjQuMiAyOC42IDMxIDMzLjYgNTQgMzkuNiAxNS4yIDQgNDIuMiAzIDUxLjQtMS44IDktNC42IDE4LTE1LjIgMjQuNC0yOS4yIDExLjQtMjQuMiA3LjQtMzEuMi0yMC42LTM2LjgtOS44LTItMjkuMi04LTQzLjQtMTMuNC00MC40LTE1LjgtNjQuNi0zNy40LTg1LjQtNzYuMi0xMS42LTIxLjgtMTUuNC0zMy0xOC4yLTUzLjYtNC4yLTMyLjItNC44LTYwLjItMS40LTg0IDMuNC0yMy44IDYuOC0zMi44IDIwLjItNTQgNC02IDguOC0xNS42IDExLTIxLjQgMy44LTEwIDMuOC0xMS42IDEtMzAtNS4yLTM0LjItMy4yLTUyLjQgNy42LTcwLjIgNy4yLTEyLjIgMTUtMTcuMiAyNC4yLTE1LjggMTIuOCAyLjIgNTIgMTcuNCA2Ni44IDI2LjIgMjYgMTUgMjkgMTUuNCA4Mi40IDcuMiAyNC42LTMuOCAzMy44LTQuMiA2MC0zLjIgMTcgLjYgNDEuNCAzIDU0IDUuMiAzOC40IDYuNiA0OS42IDUuMiA3My0xMCA2LjYtNC4yIDE3LjQtOS40IDI0LTExLjYgNi42LTIuMiAxNi01LjggMjEtOC4yIDEzLTYgMjgtNS42IDM1LjYuOCAxMi40IDEwLjQgMTguNiA0MS40IDE0LjQgNzEuNi00LjQgMzAuNi0zIDM5LjQgOC40IDUzLjggMy40IDQuNCAxMS4yIDE5LjIgMTcuNCAzMy4yTDc3NSA0NDN2NzhsLTEwIDI4Yy0xNS4yIDQzLjItMzYuOCA3My4yLTY2LjIgOTIuOC0xMy40IDguOC01NyAyNS40LTc2LjggMjktMjguMiA1LjItMzMuMiAxMi42LTIyIDMyLjIgMTEuMiAxOS40IDEyLjQgMzIuOCAxMS42IDEyOS42bC0uNiA4NS44IDUuNCA0LjZjMy42IDMgOS4yIDUuMiAxNiA2IDUuOC44IDYwLjIgMSAxMjAuNi42IDEwOC40LS42IDExMC4yLS42IDExOS01IDI0LTExLjYgNDAtMjcuNCA1MS42LTUwLjZsNS40LTExIC42LTM0N2MuNC0yMjMtLjItMzUzLjQtMS40LTM2NS0yLTE3LTIuNi0xOC42LTEzLTM0LTEwLjYtMTUuNC0yMi44LTI2LjItNDMuMi0zNy4yLTQuMi0yLjQtNjQuNi0yLjgtMzY2LTMuMi0xOTguNiAwLTM2NCAuNC0zNjcuNiAxLjR6Ii8+PC9zdmc+);
    }
    
    
    
    
    
</style>

        
        <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons"rel="stylesheet">


        <script>lsloader.load("js/jquery.min.js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==")</script>
    
    
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Analytics -->
    

    <!-- Custom Head -->
    
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->

    <!-- Left aligned menu below button -->
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    
    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#引言"><span class="post-toc-number">1.</span> <span class="post-toc-text">引言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#目录内容"><span class="post-toc-number">2.</span> <span class="post-toc-text">目录内容</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#协程基础"><span class="post-toc-number">3.</span> <span class="post-toc-text">协程基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#你的第一个协程"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">你的第一个协程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#桥接阻塞和非阻塞的世界"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">桥接阻塞和非阻塞的世界</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#等待一个工作"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">等待一个工作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数提取重构"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">函数提取重构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#协程是轻量级的"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">协程是轻量级的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#协程就像守护线程"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">协程就像守护线程</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#取消和超时"><span class="post-toc-number">4.</span> <span class="post-toc-text">取消和超时</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#取消协程的执行"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">取消协程的执行</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#取消是合作的"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">取消是合作的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使计算代码可取消的"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">使计算代码可取消的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在最后关闭资源"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">在最后关闭资源</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#运行不可取消的代码块"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">运行不可取消的代码块</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#超时"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">超时</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#组合挂起函数"><span class="post-toc-number">5.</span> <span class="post-toc-text">组合挂起函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#默认顺序"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">默认顺序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用异步并发"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">使用异步并发</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#懒异步启动"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">懒异步启动</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异步风格函数"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">异步风格函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#协程上下文和调度器"><span class="post-toc-number">6.</span> <span class="post-toc-text">协程上下文和调度器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#调度器和线程"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">调度器和线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#受限和不受限调度器的区别"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">受限和不受限调度器的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#调试协程和线程"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">调试协程和线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程间跳转"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">线程间跳转</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在上下文中工作"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">在上下文中工作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#协程的孩子"><span class="post-toc-number">6.6.</span> <span class="post-toc-text">协程的孩子</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#组合上下文"><span class="post-toc-number">6.7.</span> <span class="post-toc-text">组合上下文</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#父类的责任"><span class="post-toc-number">6.8.</span> <span class="post-toc-text">父类的责任</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为调试命名协程"><span class="post-toc-number">6.9.</span> <span class="post-toc-text">为调试命名协程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#工作的显式取消"><span class="post-toc-number">6.10.</span> <span class="post-toc-text">工作的显式取消</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#通道"><span class="post-toc-number">7.</span> <span class="post-toc-text">通道</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通道基础"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">通道基础</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通道关闭和迭代"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">通道关闭和迭代</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#构建通道生产者"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">构建通道生产者</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#管道"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">管道</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#素数与管道"><span class="post-toc-number">7.5.</span> <span class="post-toc-text">素数与管道</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#扇出"><span class="post-toc-number">7.6.</span> <span class="post-toc-text">扇出</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#扇入"><span class="post-toc-number">7.7.</span> <span class="post-toc-text">扇入</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#缓冲通道"><span class="post-toc-number">7.8.</span> <span class="post-toc-text">缓冲通道</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通道是公平的"><span class="post-toc-number">7.9.</span> <span class="post-toc-text">通道是公平的</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#共享可变状态和并发"><span class="post-toc-number">8.</span> <span class="post-toc-text">共享可变状态和并发</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#问题"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Volatiles没有用"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">Volatiles没有用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程安全的数据结构"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">线程安全的数据结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程约束细粒度"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">线程约束细粒度</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程约束粗粒度"><span class="post-toc-number">8.5.</span> <span class="post-toc-text">线程约束粗粒度</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#互斥"><span class="post-toc-number">8.6.</span> <span class="post-toc-text">互斥</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Actors行动者"><span class="post-toc-number">8.7.</span> <span class="post-toc-text">Actors行动者</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#选择表达式"><span class="post-toc-number">9.</span> <span class="post-toc-text">选择表达式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#从通道中选择"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">从通道中选择</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#关闭选择"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">关闭选择</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选择发送"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">选择发送</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选择延迟值"><span class="post-toc-number">9.4.</span> <span class="post-toc-text">选择延迟值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切换延迟值的通道"><span class="post-toc-number">9.5.</span> <span class="post-toc-text">切换延迟值的通道</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进阶阅读"><span class="post-toc-number">10.</span> <span class="post-toc-text">进阶阅读</span></a></li></ol>
        <!--
        <li class="mdl-menu__item">
            Some Action
        </li>
        -->
    </ul>
    





<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        <!-- Custom Thumbnail -->
        <div class="post_thumbnail-custom mdl-card__media mdl-color-text--grey-50" style="background-image:url(/img/kotlin_future.jpg)">
    
            <p class="article-headline-p">
                Kotlin协程入门指南（译文）
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.jpg" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Ethan Hua</strong>
        <span>2月 27, 2018</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/Kotlin/">Kotlin</a>
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=Kotlin协程入门指南（译文）&url=http://yoursite.com/2018/02/27/coroutines-guide_cn/index.html&pic=&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=Kotlin协程入门指南（译文）&url=http://yoursite.com/2018/02/27/coroutines-guide_cn/index.html&via=Ethan Hua" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2018/02/27/coroutines-guide_cn/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://yoursite.com/2018/02/27/coroutines-guide_cn/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <blockquote>
<p>原文链接：<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md" target="_blank" rel="noopener">https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md</a>  </p>
</blockquote>
<p>这是一份<code>kotlinx.coroutines</code>核心特性的指南，它包含许多有趣的例子。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kotlin 作为一种语言在标准库中提供了最低限度的底层 API 以支持其它库使用协程. 不同于其它一些类似功能的语言，<code>async</code> 和 <code>wait</code> 并不是Kotlin中的关键字，甚至不是标准库的一部分。<br><code>kotlinx.coroutines</code> 是一个包含了本指南所涵盖的许多高级别的协程基础元素的丰富库，包括<code>launch</code>, <code>async</code> 和其他一些元素，使用协程需要你添加一个依赖 <code>kotlinx-coroutines-core</code> 模块在你的项目中。</p>
<h2 id="目录内容"><a href="#目录内容" class="headerlink" title="目录内容"></a>目录内容</h2><!--- TOC -->
<ul>
<li><a href="#协程基础">协程基础</a><ul>
<li><a href="#你的第一个协程">你的第一个协程</a></li>
<li><a href="#桥接阻塞和非阻塞的世界">桥接阻塞和非阻塞的世界</a></li>
<li><a href="#等待一个工作">等待一个工作</a></li>
<li><a href="#函数提取重构">函数提取重构</a></li>
<li><a href="#协程是轻量级的">协程是轻量级的</a></li>
<li><a href="#协程就像守护线程">协程就像守护线程</a></li>
</ul>
</li>
<li><a href="#取消和超时">取消和超时</a><ul>
<li><a href="#取消协程的执行">取消协程的执行</a></li>
<li><a href="#取消是合作的">取消是合作的</a></li>
<li><a href="#使计算代码可取消的">使计算代码可取消的</a></li>
<li><a href="#在最后关闭资源">在最后关闭资源</a></li>
<li><a href="#运行不可取消的代码块">运行不可取消的代码块</a></li>
<li><a href="#超时">超时</a></li>
</ul>
</li>
<li><a href="#组合挂起函数">组合挂起函数</a><ul>
<li><a href="#默认顺序">默认顺序</a></li>
<li><a href="#使用异步并发">使用异步并发</a></li>
<li><a href="#懒异步启动">懒异步启动</a></li>
<li><a href="#异步风格函数">异步风格函数</a></li>
</ul>
</li>
<li><a href="#协程上下文和调度器">协程上下文和调度器</a><ul>
<li><a href="#调度器和线程">调度器和线程</a></li>
<li><a href="#受限和不受限调度器的区别">受限和不受限调度器的区别</a></li>
<li><a href="#调试协程和线程">调试协程和线程</a></li>
<li><a href="#线程间跳转">线程间跳转</a></li>
<li><a href="#在上下文中工作">在上下文中工作</a></li>
<li><a href="#协程的孩子">协程的孩子</a></li>
<li><a href="#组合上下文">组合上下文</a></li>
<li><a href="#父类的责任">父类的责任</a></li>
<li><a href="#为调试命名协程">为调试命名协程</a></li>
<li><a href="#工作的显式取消">工作的显式取消</a></li>
</ul>
</li>
<li><a href="#通道">通道</a><ul>
<li><a href="#通道基础">通道基础</a></li>
<li><a href="#通道关闭和迭代">通道关闭和迭代</a></li>
<li><a href="#构建通道生产者">构建通道生产者</a></li>
<li><a href="#管道">管道</a></li>
<li><a href="#素数与管道">素数与管道</a></li>
<li><a href="#扇出">扇出</a></li>
<li><a href="#扇入">扇入</a></li>
<li><a href="#缓冲通道">缓冲通道</a></li>
<li><a href="#通道是公平的">通道是公平的</a></li>
</ul>
</li>
<li><a href="#共享可变状态和并发">共享可变状态和并发</a><ul>
<li><a href="#问题">问题</a></li>
<li><a href="#Volatiles没有用">Volatiles 没有用</a></li>
<li><a href="#线程安全的数据结构">线程安全的数据结构</a></li>
<li><a href="#线程约束细粒度">线程约束细粒度</a></li>
<li><a href="#线程约束粗粒度">线程约束粗粒度</a></li>
<li><a href="#互斥">互斥</a></li>
<li><a href="#Actors行动者">Actors行动者</a></li>
</ul>
</li>
<li><a href="#选择表达式">选择表达式</a><ul>
<li><a href="#从通道中选择">从通道中选择</a></li>
<li><a href="#关闭选择">关闭选择</a></li>
<li><a href="#选择发送">选择发送</a></li>
<li><a href="#选择延迟值">选择延迟值</a></li>
<li><a href="#切换延迟值的通道">切换延迟值的通道</a></li>
</ul>
</li>
<li><a href="#进阶阅读">进阶阅读</a></li>
</ul>
<!--- END_TOC -->
<h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><p>本节将介绍协程的基本概念</p>
<h3 id="你的第一个协程"><a href="#你的第一个协程" class="headerlink" title="你的第一个协程"></a>你的第一个协程</h3><p>运行下面的代码：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    launch <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// launch new coroutine in background and continue</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// non-blocking delay for 1 second (default time unit is ms)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// print after delay</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// main thread continues while coroutine is delayed</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// block main thread for 2 seconds to keep JVM alive</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-01.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>运行这段代码：</p>
<pre class=" language-text"><code class="language-text">Hello,
World!
</code></pre>
<!--- TEST -->
<p>本质上协程是轻量级的线程，他们被协程<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html" target="_blank" rel="noopener">launch</a>构造器启动，你可以用 <code>thread { ... }</code> 替代 <code>launch { ... }</code> 和用 <code>Thread.sleep(...)</code> 替代 <code>delay(...)</code>实现相同的结果，试试看。</p>
<p>如果你开始用 <code>thread</code> 替代 <code>launch</code> 编译器会产生下面的错误：</p>
<pre><code>Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function
</code></pre><p>这是因为 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/delay.html" target="_blank" rel="noopener">delay</a> 是一种特殊的 <em>suspending function</em>（挂起函数），它不会阻塞线程但是会挂起协程，而且它只能用于协程。</p>
<h3 id="桥接阻塞和非阻塞的世界"><a href="#桥接阻塞和非阻塞的世界" class="headerlink" title="桥接阻塞和非阻塞的世界"></a>桥接阻塞和非阻塞的世界</h3><p>上面的第一个例子在同一份代码中混合了非阻塞的 <code>delay(...)</code> 和 阻塞的 <code>Thread.sleep(...)</code></p>
<p>非常容易混淆哪一个是阻塞的哪一个是非阻塞的，我们使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run-blocking.html" target="_blank" rel="noopener">runBlocking</a> 协程构造器来明确阻塞：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    launch <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// launch new coroutine in background and continue</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// main thread continues here immediately</span>
    runBlocking <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// but this expression blocks the main thread</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000L</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// ... while we delay for 2 seconds to keep JVM alive</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-02.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST
Hello,
World!
-->
<p>结果是相同的，但是这段代码只使用了非阻塞的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/delay.html" target="_blank" rel="noopener">delay</a>.调用 <code>runBlocking</code>的主线程会一直阻塞直到在 <code>runBlocking</code>里面的协程运行完成。</p>
<p>这个例子也可以用一种更地道的方式重写，用<code>runBlocking</code> 包装 main 函数的执行：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// start main coroutine</span>
    launch <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// launch new coroutine in background and continue</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// main coroutine continues here immediately</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000L</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// delaying for 2 seconds to keep JVM alive</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-02b.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST
Hello,
World!
-->
<p>这里 <code>runBlocking&lt;Unit&gt; { ... }</code> 作为一个适配器用于启动顶层的 main 协程.我们显示地指定了它的 <code>Unit</code> 返回类型，因为在Kotlin中一个格式良好的 <code>main</code> 函数必须返回 <code>Unit</code>。</p>
<p>这也是为挂起函数编写单元测试的一种方式:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MyTest <span class="token punctuation">{</span>
    <span class="token annotation builtin">@Test</span>
    <span class="token keyword">fun</span> <span class="token function">testMySuspendingFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// here we can use suspending functions using any assertion style that we like</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<!--- CLEAR -->
<h3 id="等待一个工作"><a href="#等待一个工作" class="headerlink" title="等待一个工作"></a>等待一个工作</h3><p>当另一个协程正在工作时去延迟一段时间不是一个好的方法，让我们明确地以一种非阻塞的方式等待直到我们启动的后台任务完成：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// launch new coroutine and keep a reference to its Job</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,"</span><span class="token punctuation">)</span>
    job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// wait until child coroutine completes</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-03.kt" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<!--- TEST
Hello,
World!
-->
<p>现在的结果仍然是一样的，但是 main 协程的代码并没有以任何方式绑定到后台工作的过程中，好多了。</p>
<h3 id="函数提取重构"><a href="#函数提取重构" class="headerlink" title="函数提取重构"></a>函数提取重构</h3><p>我们提取 <code>launch { ... }</code> 里面的代码块到一个独立的函数中. 在这段代码上执行“Extract function”提取重构，您将得到一个具有 <code>suspend</code> 修饰符的新函数。这是你的第一个 <em>挂起</em> 函数，挂起函数可以像普通函数一样在协程中使用，但是他们额外的功能是可以使用其它的挂起函数，比如在这个例子中的 <code>delay</code> 函数，来挂起协程的执行：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">{</span> <span class="token function">doWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,"</span><span class="token punctuation">)</span>
    job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// this is your first suspending function</span>
suspend <span class="token keyword">fun</span> <span class="token function">doWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-04.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST
Hello,
World!
-->
<h3 id="协程是轻量级的"><a href="#协程是轻量级的" class="headerlink" title="协程是轻量级的"></a>协程是轻量级的</h3><p>运行下面的代码:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> jobs <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span>100_000<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// launch a lot of coroutines and list their jobs</span>
        launch <span class="token punctuation">{</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    jobs<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// wait for all jobs to complete</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-05.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST lines.size == 1 && lines[0] == ".".repeat(100_000) -->
<p>这段程序启动了10万个协程，一秒后每一个协程打印了一个 “.” ，现在用线程来试一试，会发生什么？（很可能你的代码会产生一些内存溢出的错误）</p>
<h3 id="协程就像守护线程"><a href="#协程就像守护线程" class="headerlink" title="协程就像守护线程"></a>协程就像守护线程</h3><p>下面的代码启动了一个每隔500ms打印一次 “I’m sleeping”的长时间运行的协程, 并延迟一段时间后从 main 函数中返回</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    launch <span class="token punctuation">{</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">-></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm sleeping <span class="token interpolation variable">$i</span> ..."</span><span class="token punctuation">)</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500L</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1300L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// just quit after delay</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-06.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>您可以运行并看到它打印三行后终止了:</p>
<pre class=" language-text"><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
</code></pre>
<!--- TEST -->
<p>活动的协程并不会保证当前的进程的存活，协程就像守护线程。</p>
<h2 id="取消和超时"><a href="#取消和超时" class="headerlink" title="取消和超时"></a>取消和超时</h2><p>本节将讨论协程的取消和超时.</p>
<h3 id="取消协程的执行"><a href="#取消协程的执行" class="headerlink" title="取消协程的执行"></a>取消协程的执行</h3><p>在小的应用中 “main” 方法的返回可能像是一个使所有协程隐式地终止的好主意，在一个更大的长时间运行的应用中，你需要更细粒度的控制。<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html" target="_blank" rel="noopener">launch</a> 函数返回的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a> 可以用来取消协程的运行：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">{</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">-></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm sleeping <span class="token interpolation variable">$i</span> ..."</span><span class="token punctuation">)</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500L</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1300L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// delay a bit</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: I'm tired of waiting!"</span><span class="token punctuation">)</span>
    job<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancels the job</span>
    job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// waits for job's completion </span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: Now I can quit."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-01.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>它会产生下面的输出：</p>
<pre class=" language-text"><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
</code></pre>
<!--- TEST -->
<p>一旦 main 函数调用了 <code>job.cancel</code>，我们没有看到其它协程的输出因为它被取消了, 还有一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a> 扩展函数 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/cancel-and-join.html" target="_blank" rel="noopener">cancelAndJoin</a>，它组合了 [cancel] 和 [join] 调用。</p>
<h3 id="取消是合作的"><a href="#取消是合作的" class="headerlink" title="取消是合作的"></a>取消是合作的</h3><p>协程取消是合作的，协程代码必须合作才能被取消，所有的在 <code>kotlinx.coroutines</code> 中的挂起函数都是可取消的，他们检查协程是否被取消了，如果已经取消则会抛出 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-cancellation-exception/index.html" target="_blank" rel="noopener">CancellationException</a> 异常，然而一个正工作在计算线程中且没有检查取消的协程就不能被取消，就像下面例子这样：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">{</span>
        <span class="token keyword">var</span> nextPrintTime <span class="token operator">=</span> startTime
        <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// computation loop, just wastes CPU</span>
            <span class="token comment" spellcheck="true">// print a message twice a second</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> nextPrintTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm sleeping <span class="token interpolation"><span class="token delimiter variable">${</span>i<span class="token operator">++</span><span class="token delimiter variable">}</span></span> ..."</span><span class="token punctuation">)</span>
                nextPrintTime <span class="token operator">+=</span> <span class="token number">500L</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1300L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// delay a bit</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: I'm tired of waiting!"</span><span class="token punctuation">)</span>
    job<span class="token punctuation">.</span><span class="token function">cancelAndJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancels the job and waits for its completion</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: Now I can quit."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-02.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>运行后可以看到它将继续打印 “I’m sleeping” 即使在协程取消后直到完成5次迭代任务完成。</p>
<!--- TEST 
I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
main: I'm tired of waiting!
I'm sleeping 3 ...
I'm sleeping 4 ...
main: Now I can quit.
-->
<h3 id="使计算代码可取消的"><a href="#使计算代码可取消的" class="headerlink" title="使计算代码可取消的"></a>使计算代码可取消的</h3><p>有两种方式可以使计算代码可以被取消，第一个是周期性调用一个挂起函数检查是否取消，有一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/yield.html" target="_blank" rel="noopener">yield</a> 函数是一个达到此目的的一个很好的选择，另一个是显示地检查取消状态，让我们试试后面一个的方法，将 <code>while (i &lt; 5)</code> 替换为 <code>while (isActive)</code> 并重新运行它：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">{</span>
        <span class="token keyword">var</span> nextPrintTime <span class="token operator">=</span> startTime
        <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>isActive<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// cancellable computation loop</span>
            <span class="token comment" spellcheck="true">// print a message twice a second</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> nextPrintTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm sleeping <span class="token interpolation"><span class="token delimiter variable">${</span>i<span class="token operator">++</span><span class="token delimiter variable">}</span></span> ..."</span><span class="token punctuation">)</span>
                nextPrintTime <span class="token operator">+=</span> <span class="token number">500L</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1300L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// delay a bit</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: I'm tired of waiting!"</span><span class="token punctuation">)</span>
    job<span class="token punctuation">.</span><span class="token function">cancelAndJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancels the job and waits for its completion</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: Now I can quit."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-03.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>如你所见，现在这个循环被取消了。<a href="">isActive</a> 是一个表示当前协程是否可用的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/index.html" target="_blank" rel="noopener">CoroutineScope</a> 对象的属性。</p>
<!--- TEST
I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
-->
<h3 id="在最后关闭资源"><a href="#在最后关闭资源" class="headerlink" title="在最后关闭资源"></a>在最后关闭资源</h3><p>可以用一切正常的方式来处理可取消的挂起函数上抛出的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-cancellation-exception/index.html" target="_blank" rel="noopener">CancellationException</a>异常 例如, 使用<code>try {...} finally {...}</code> 表达式在协程被取消时正常地执行 finally{} 中的kotlin操作 :</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">-></span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm sleeping <span class="token interpolation variable">$i</span> ..."</span><span class="token punctuation">)</span>
                <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500L</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm running finally"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1300L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// delay a bit</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: I'm tired of waiting!"</span><span class="token punctuation">)</span>
    job<span class="token punctuation">.</span><span class="token function">cancelAndJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancels the job and waits for its completion</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: Now I can quit."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-04.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p><a href="">join</a> 和 cancelAndJoin] 都等待所有最终完成的操作，因此上面的示例产生以下输出:</p>
<pre class=" language-text"><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
main: I'm tired of waiting!
I'm running finally
main: Now I can quit.
</code></pre>
<!--- TEST -->
<h3 id="运行不可取消的代码块"><a href="#运行不可取消的代码块" class="headerlink" title="运行不可取消的代码块"></a>运行不可取消的代码块</h3><p>在前面例子中的<code>finally</code>代码块中去使用挂起函数的任何尝试都将导致<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-cancellation-exception/index.html" target="_blank" rel="noopener">CancellationException</a>异常，因为运行这段代码的这个协程已经被取消了，通常这不是一个问题，因为所有良好行为的关闭操作（关闭文件、取消作业或者关闭任何类型的通信通道）通常都是非阻塞的，并且不会调起任何挂起函数，然而在极少数情况下，当你需要在被取消的协程中挂起时，你可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-context.html" target="_blank" rel="noopener">withContext</a> 函数和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-non-cancellable/index.html" target="_blank" rel="noopener">NonCancellable</a> 上下文将相应的代码包装在 <code>withContext(NonCancellable) {...}</code> 中，如下例所示：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">-></span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm sleeping <span class="token interpolation variable">$i</span> ..."</span><span class="token punctuation">)</span>
                <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500L</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token function">withContext</span><span class="token punctuation">(</span>NonCancellable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm running finally"</span><span class="token punctuation">)</span>
                <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"And I've just delayed for 1 sec because I'm non-cancellable"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1300L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// delay a bit</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: I'm tired of waiting!"</span><span class="token punctuation">)</span>
    job<span class="token punctuation">.</span><span class="token function">cancelAndJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancels the job and waits for its completion</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: Now I can quit."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-05.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST
I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
main: I'm tired of waiting!
I'm running finally
And I've just delayed for 1 sec because I'm non-cancellable
main: Now I can quit.
-->
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>在实践中取消协程执行最明显的原因是它的执行时间超过一定的时间，虽然你可以手动跟踪相应<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a>的引用并启动一个单独的协程以便在延迟之后取消对应的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a>，但这里有一个准备好的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-timeout.html" target="_blank" rel="noopener">withTimeout</a> 函数可以轻松做这件事。</p>
<p>看下面的例子：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">withTimeout</span><span class="token punctuation">(</span><span class="token number">1300L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">-></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm sleeping <span class="token interpolation variable">$i</span> ..."</span><span class="token punctuation">)</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500L</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-06.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>它产生下面的输出：</p>
<pre class=" language-text"><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Exception in thread "main" kotlinx.coroutines.experimental.TimeoutCancellationException: Timed out waiting for 1300 MILLISECONDS
</code></pre>
<!--- TEST STARTS_WITH -->
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-timeout.html" target="_blank" rel="noopener">withTimeout</a>抛出的 <code>TimeoutCancellationException</code> 异常是 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-cancellation-exception/index.html" target="_blank" rel="noopener">CancellationException</a>异常的子类。我们还没有看到过控制台打印的堆栈跟踪，这是因为在一个取消了的协程内<code>CancellationException</code> 被认为是协程完成的一个正常的原因。但是，在这个例子中我们已经在 <code>main</code> 函数中使用了 <code>withTimeout</code>。</p>
<p>因为取消只是一个例外，所有的资源都将以通常的方式关闭。<br>你可以在 <code>try {...} catch (e: TimeoutCancellationException) {...}</code> 代码块中 用 <code>timeout</code> 来包装代码，或者使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-timeout-or-null.html" target="_blank" rel="noopener">withTimeoutOrNull</a> 函数，如果你需要对任何类型的超时去做一些额外的操作， <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-timeout-or-null.html" target="_blank" rel="noopener">withTimeoutOrNull</a> 函数类似于 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-timeout.html" target="_blank" rel="noopener">withTimeout</a>,但是在超时时返回 <code>null</code> 而不是异常</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token function">withTimeoutOrNull</span><span class="token punctuation">(</span><span class="token number">1300L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">-></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm sleeping <span class="token interpolation variable">$i</span> ..."</span><span class="token punctuation">)</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500L</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token string">"Done"</span> <span class="token comment" spellcheck="true">// will get cancelled before it produces this result</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result is <span class="token interpolation variable">$result</span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-07.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>运行此代码时不再有异常:</p>
<pre class=" language-text"><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Result is null
</code></pre>
<!--- TEST -->
<h2 id="组合挂起函数"><a href="#组合挂起函数" class="headerlink" title="组合挂起函数"></a>组合挂起函数</h2><p>本节介绍各种不同挂起函数的组合方法</p>
<h3 id="默认顺序"><a href="#默认顺序" class="headerlink" title="默认顺序"></a>默认顺序</h3><p>假设我们在其它地方定义了两个挂起函数，它们可以做一些有用的事情，比如某种远程调用或计算。我们假装它们是有用的，但实际上每一个都只是为了这个例子而延迟一秒钟:</p>
<!--- INCLUDE .*/example-compose-([0-9]+).kt
import kotlin.system.measureTimeMillis
-->
<pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">doSomethingUsefulOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// pretend we are doing something useful here</span>
    <span class="token keyword">return</span> <span class="token number">13</span>
<span class="token punctuation">}</span>

suspend <span class="token keyword">fun</span> <span class="token function">doSomethingUsefulTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// pretend we are doing something useful here, too</span>
    <span class="token keyword">return</span> <span class="token number">29</span>
<span class="token punctuation">}</span>
</code></pre>
<!--- INCLUDE .*/example-compose-([0-9]+).kt -->
<p>如果需要去顺序调用它们我们该怎么做 – 首先 <code>doSomethingUsefulOne</code> 然后 <code>doSomethingUsefulTwo</code> 并计算它们结果的和？</p>
<p>在实践中我们会使用第一个函数的结果去决定是否我们需要去调用第二个函数或者怎样去调用它,我们只需要使用一个正常的顺序调用，因为协程中的代码和普通代码样默认是顺序执行的，下面的示例通过测量执行两个挂起函数所需要的总时间来演示它:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> time <span class="token operator">=</span> measureTimeMillis <span class="token punctuation">{</span>
        <span class="token keyword">val</span> one <span class="token operator">=</span> <span class="token function">doSomethingUsefulOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">val</span> two <span class="token operator">=</span> <span class="token function">doSomethingUsefulTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The answer is <span class="token interpolation"><span class="token delimiter variable">${</span>one <span class="token operator">+</span> two<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Completed in <span class="token interpolation variable">$time</span> ms"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-compose-01.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>这段代码会输出这些：</p>
<pre class=" language-text"><code class="language-text">The answer is 42
Completed in 2017 ms
</code></pre>
<!--- TEST ARBITRARY_TIME -->
<h3 id="使用异步并发"><a href="#使用异步并发" class="headerlink" title="使用异步并发"></a>使用异步并发</h3><p>如果我们想要更快的结果，要求 <code>doSomethingUsefulOne</code>和 <code>doSomethingUsefulTwo</code> 之间没有依赖，它们是并发执行的，该怎么做？<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html" target="_blank" rel="noopener">async</a> 可以帮助我们来完成。</p>
<p>从概念上来讲，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html" target="_blank" rel="noopener">async</a> 就像 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html" target="_blank" rel="noopener">launch</a>。它启动了一个独立的协程，这个协程是一个轻量级的线程，其它所有的协程并发工作。 区别在于 <code>launch</code> 返回一个不带任何结果值的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a>，而 <code>async</code> 返回一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-deferred/index.html" target="_blank" rel="noopener">Deferred</a> – 一个轻量非阻塞的未来，代表了以后提供结果的承诺。你可以在一个 deferred 值上使用     <code>.await()</code> 来得到它最终的结果，<code>Deferred</code> 也是一个 <code>Job</code>， 所以你也能在有需要时取消它</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> time <span class="token operator">=</span> measureTimeMillis <span class="token punctuation">{</span>
        <span class="token keyword">val</span> one <span class="token operator">=</span> async <span class="token punctuation">{</span> <span class="token function">doSomethingUsefulOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token keyword">val</span> two <span class="token operator">=</span> async <span class="token punctuation">{</span> <span class="token function">doSomethingUsefulTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The answer is <span class="token interpolation"><span class="token delimiter variable">${</span>one<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> two<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Completed in <span class="token interpolation variable">$time</span> ms"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-compose-02.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>这段代码会输出这些：</p>
<pre class=" language-text"><code class="language-text">The answer is 42
Completed in 1017 ms
</code></pre>
<!--- TEST ARBITRARY_TIME -->
<p>这次快了两倍，因为我们并发执行了两个协程。注意，协程的并发始终是显式的。</p>
<h3 id="懒异步启动"><a href="#懒异步启动" class="headerlink" title="懒异步启动"></a>懒异步启动</h3><p>对于 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html" target="_blank" rel="noopener">async</a> 有一个 “懒启动” 配置项，在参数 <code>start</code> 中使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-start/-l-a-z-y.html" target="_blank" rel="noopener">CoroutineStart.LAZY</a> 值。仅仅当它的结果被需要时才会启动执行协程，如调用了 <a href="">await</a> 或者 <a href="">start</a> 函数。</p>
<p>运行下面这个示例，与上一个示例不同，这里使用了 “懒启动” 选项</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> time <span class="token operator">=</span> measureTimeMillis <span class="token punctuation">{</span>
        <span class="token keyword">val</span> one <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>start <span class="token operator">=</span> CoroutineStart<span class="token punctuation">.</span>LAZY<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">doSomethingUsefulOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token keyword">val</span> two <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>start <span class="token operator">=</span> CoroutineStart<span class="token punctuation">.</span>LAZY<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">doSomethingUsefulTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The answer is <span class="token interpolation"><span class="token delimiter variable">${</span>one<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> two<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Completed in <span class="token interpolation variable">$time</span> ms"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-compose-03.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>这段代码会输出这些：</p>
<pre class=" language-text"><code class="language-text">The answer is 42
Completed in 2017 ms
</code></pre>
<!--- TEST ARBITRARY_TIME -->
<p>因此我们又回到了顺序执行，因为我们 首先启动并等待 <code>one</code> 然后启动并等待 <code>two</code>。这不是一个想要的懒用例。懒异步被设计用于当计算值涉及到挂起函数时取代标准的 <code>lazy</code> 函数</p>
<h3 id="异步风格函数"><a href="#异步风格函数" class="headerlink" title="异步风格函数"></a>异步风格函数</h3><p>我们可以定义使用协程异步构造器的异步风格函数异步地调用 <code>doSomethingUsefulOne</code> 和 <code>doSomethingUsefulTwo</code>。用 “Async” 后缀来命名这样的函数是一种很好的方式，它强调了这样一个事实:它们只启动异步计算，并且需要使用产生的延迟值来获得结果。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// The result type of somethingUsefulOneAsync is Deferred&lt;Int></span>
<span class="token keyword">fun</span> <span class="token function">somethingUsefulOneAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> async <span class="token punctuation">{</span>
    <span class="token function">doSomethingUsefulOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// The result type of somethingUsefulTwoAsync is Deferred&lt;Int></span>
<span class="token keyword">fun</span> <span class="token function">somethingUsefulTwoAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> async <span class="token punctuation">{</span>
    <span class="token function">doSomethingUsefulTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>注意，这些 <code>xxxAsync</code> 函数不是挂起函数他们可以在任意地方被使用。然而，他们的使用经常暗示着他们的操作调用代码的执行是异步的</p>
<p>下面的例子展示了他们在协程之外的用法： </p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// note, that we don't have `runBlocking` to the right of `main` in this example</span>
<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> time <span class="token operator">=</span> measureTimeMillis <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// we can initiate async actions outside of a coroutine</span>
        <span class="token keyword">val</span> one <span class="token operator">=</span> <span class="token function">somethingUsefulOneAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">val</span> two <span class="token operator">=</span> <span class="token function">somethingUsefulTwoAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">// but waiting for a result must involve either suspending or blocking.</span>
        <span class="token comment" spellcheck="true">// here we use `runBlocking { ... }` to block the main thread while waiting for the result</span>
        runBlocking <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The answer is <span class="token interpolation"><span class="token delimiter variable">${</span>one<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> two<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Completed in <span class="token interpolation variable">$time</span> ms"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-compose-04.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST ARBITRARY_TIME
The answer is 42
Completed in 1085 ms
-->
<h2 id="协程上下文和调度器"><a href="#协程上下文和调度器" class="headerlink" title="协程上下文和调度器"></a>协程上下文和调度器</h2><p>协程总是执行在某些上下文中，这些上下文由 Kotlin 标准库中定义的 [CoroutineContext] 类型的值来表示的。协程上下文是一个不同元素的集合，主要的元素是协程中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a>，我们之前看到过，本节我们将会介绍它的调度器。</p>
<h3 id="调度器和线程"><a href="#调度器和线程" class="headerlink" title="调度器和线程"></a>调度器和线程</h3><p>协程上下文包含协程调度器，协程调度器决定协程执行时的线程或者相应协程使用的线程。协程调度器可以将协程的执行限制为一个特定的线程，将其分派给线程池，或者让它不受限制地运行。</p>
<p>所有的协程构造器如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html" target="_blank" rel="noopener">launch</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html" target="_blank" rel="noopener">async</a> ，接收一个可选项 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-coroutine-context/" target="_blank" rel="noopener">CoroutineContext</a> ，这个可选项用来显示地指定新协程和它的其它上下文元素的调度器。</p>
<p>试一试下面的例子：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> jobs <span class="token operator">=</span> arrayListOf<span class="token operator">&lt;</span>Job<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    jobs <span class="token operator">+=</span> <span class="token function">launch</span><span class="token punctuation">(</span>Unconfined<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// not confined -- will work with main thread</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"      'Unconfined': I'm working in thread <span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    jobs <span class="token operator">+=</span> <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// context of the parent, runBlocking coroutine</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"'coroutineContext': I'm working in thread <span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    jobs <span class="token operator">+=</span> <span class="token function">launch</span><span class="token punctuation">(</span>CommonPool<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// will get dispatched to ForkJoinPool.commonPool (or equivalent)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"      'CommonPool': I'm working in thread <span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    jobs <span class="token operator">+=</span> <span class="token function">launch</span><span class="token punctuation">(</span><span class="token function">newSingleThreadContext</span><span class="token punctuation">(</span><span class="token string">"MyOwnThread"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// will get its own new thread</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"          'newSTC': I'm working in thread <span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    jobs<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-01.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>它产生下面的输出（可能是不同的顺序）</p>
<pre class=" language-text"><code class="language-text">      'Unconfined': I'm working in thread main
      'CommonPool': I'm working in thread ForkJoinPool.commonPool-worker-1
          'newSTC': I'm working in thread MyOwnThread
'coroutineContext': I'm working in thread main
</code></pre>
<!--- TEST LINES_START_UNORDERED -->
<p>我们在前面部分中使用的默认调度器是由 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-default-dispatcher.html" target="_blank" rel="noopener">DefaultDispatcher</a>表示的，它在当前实现中等于<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-common-pool/index.html" target="_blank" rel="noopener">CommonPool</a>，所以 <code>launch { ... }</code>、<code>launch(DefaultDispatcher) { ... }</code>、<code>launch(CommonPool) { ... }</code>使用的是相同的调度器，父类[coroutineContext]和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-unconfined/index.html" target="_blank" rel="noopener">Unconfined</a>不限制上下文之间的不同将会在稍后介绍。注意，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/new-single-thread-context.html" target="_blank" rel="noopener">newSingleThreadContext</a> 创建了一个新的线程，这是一个非常昂贵的资源。<br>在实际应用程序中必须在不在需要的时候，使用 <a href="">close</a> 函数释放它，或者将其存储在顶层变量中，并在整个应用程序中重用。</p>
<h3 id="受限和不受限调度器的区别"><a href="#受限和不受限调度器的区别" class="headerlink" title="受限和不受限调度器的区别"></a>受限和不受限调度器的区别</h3><p>无限制协程分发器在调用者的线程中启动协程，但直到第一个挂起点，在挂起后它在线程中的恢复完全由被调用的挂起函数决定， 当协程不消耗CPU事件，也不更新限制在特定线程的共享数据（如UI）时，不受限调度器是合适的。</p>
<p>在另一方面，<a href="">coroutineContext</a> 属性可以通过 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/index.html" target="_blank" rel="noopener">CoroutineScope</a> 接口在任何协程代码块中使用，这是对这个特定的协程上下文的引用。<br>这种方式，父类上下文可以被继承，特别是 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run-blocking.html" target="_blank" rel="noopener">runBlocking</a> 协程的默认调度器只受限于调用的线程，因此继承它具有将执行限制到该线程的效果，并具有可预测的FIFO调度。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> jobs <span class="token operator">=</span> arrayListOf<span class="token operator">&lt;</span>Job<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    jobs <span class="token operator">+=</span> <span class="token function">launch</span><span class="token punctuation">(</span>Unconfined<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// not confined -- will work with main thread</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"      'Unconfined': I'm working in thread <span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"      'Unconfined': After delay in thread <span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    jobs <span class="token operator">+=</span> <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// context of the parent, runBlocking coroutine</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"'coroutineContext': I'm working in thread <span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"'coroutineContext': After delay in thread <span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    jobs<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-02.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>产生的输出：</p>
<pre class=" language-text"><code class="language-text">      'Unconfined': I'm working in thread main
'coroutineContext': I'm working in thread main
      'Unconfined': After delay in thread kotlinx.coroutines.DefaultExecutor
'coroutineContext': After delay in thread main
</code></pre>
<!--- TEST LINES_START -->
<p>因此继承了 <code>runBlocking {...}</code> 中 <code>coroutineContext</code> 的协程继续在 <code>main</code> 线程中执行, 而不受限的协程在延迟delay函数正在使用的默认执行线程中恢复执行。</p>
<h3 id="调试协程和线程"><a href="#调试协程和线程" class="headerlink" title="调试协程和线程"></a>调试协程和线程</h3><p>协程可以在一个线程上挂起然后在另一个使用不受限调度器或者一个默认多线程调度器的线程上恢复。即使使用单线程调度器也很难弄清楚 协程 在做什么、在哪里、何时在做。调试使用线程的应用程序的常见方法是在每个日志语句的日志文件中打印线程名，这个特性通常在日志框架中会被支持，当使用协程，单独的线程名并不能提供很多上下文信息，所以 <code>kotlinx.coroutines</code> 中包含调试工具使它更容易。</p>
<p>使用 <code>-Dkotlinx.coroutines.debug</code> JVM 选项运行下面的代码 </p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"[<span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>] <span class="token interpolation variable">$msg</span>"</span><span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"I'm computing a piece of the answer"</span><span class="token punctuation">)</span>
        <span class="token number">6</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">val</span> b <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"I'm computing another piece of the answer"</span><span class="token punctuation">)</span>
        <span class="token number">7</span>
    <span class="token punctuation">}</span>
    <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"The answer is <span class="token interpolation"><span class="token delimiter variable">${</span>a<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-03.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>这儿有三个协程，主协程 <code>runBlocking</code>，两个协程计算延迟值 <code>a</code> 和 <code>b</code>。他们都执行在 <code>runBlocking</code> 的上下文中并受限在 <code>main</code> 线程  这段代码的输出:</p>
<pre class=" language-text"><code class="language-text">[main @coroutine#2] I'm computing a piece of the answer
[main @coroutine#3] I'm computing another piece of the answer
[main @coroutine#1] The answer is 42
</code></pre>
<!--- TEST FLEXIBLE_THREAD -->
<p>可以看到日志函数在方括号里面打印了线程的名称，而且当前执行的协程的标识符也添加在其后面。当调试模式打开时，这个标识符会被连续地分配给所有创建的协程。</p>
<p>您可以在<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/new-coroutine-context.html" target="_blank" rel="noopener">newCoroutineContext</a>函数的文档中了解更多关于调试工具的内容。</p>
<h3 id="线程间跳转"><a href="#线程间跳转" class="headerlink" title="线程间跳转"></a>线程间跳转</h3><p>使用 <code>-Dkotlinx.coroutines.debug</code> JVM可选项运行下面的代码</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"[<span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>] <span class="token interpolation variable">$msg</span>"</span><span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">newSingleThreadContext</span><span class="token punctuation">(</span><span class="token string">"Ctx1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">use</span> <span class="token punctuation">{</span> ctx1 <span class="token operator">-></span>
        <span class="token function">newSingleThreadContext</span><span class="token punctuation">(</span><span class="token string">"Ctx2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">use</span> <span class="token punctuation">{</span> ctx2 <span class="token operator">-></span>
            <span class="token function">runBlocking</span><span class="token punctuation">(</span>ctx1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Started in ctx1"</span><span class="token punctuation">)</span>
                <span class="token function">withContext</span><span class="token punctuation">(</span>ctx2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Working in ctx2"</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
                <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Back to ctx1"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-04.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>它演示了几种新技术。一个是使用带有显示指定上下文的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run-blocking.html" target="_blank" rel="noopener">runBlocking</a>，另一个是使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-context.html" target="_blank" rel="noopener">withContext</a> 函数来更改协程的上下文，同时仍然保持运行在相同的协程中，正如你再下面的输出中看到的那样。</p>
<pre class=" language-text"><code class="language-text">[Ctx1 @coroutine#1] Started in ctx1
[Ctx2 @coroutine#1] Working in ctx2
[Ctx1 @coroutine#1] Back to ctx1
</code></pre>
<!--- TEST -->
<p>注意，这个示例还使用了Kotlin标准库中的 <code>use</code> 函数，以释放在不再需要时使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/new-single-thread-context.html" target="_blank" rel="noopener">newSingleThreadContext</a> 创建的线程。</p>
<h3 id="在上下文中工作"><a href="#在上下文中工作" class="headerlink" title="在上下文中工作"></a>在上下文中工作</h3><p>协程的 <a href="">Job</a> 是其上下文 context 的一部分，协程可以使用 <code>coroutineContext[Job]</code> 表达式从自己的上下文context中检索它：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"My job is <span class="token interpolation"><span class="token delimiter variable">${</span>coroutineContext<span class="token punctuation">[</span>Job<span class="token punctuation">]</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-05.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>在调试模式下它会产生像下面这样的代码：</p>
<pre><code>My job is &quot;coroutine#1&quot;:BlockingCoroutine{Active}@6d311334
</code></pre><!--- TEST lines.size == 1 && lines[0].startsWith("My job is \"coroutine#1\":BlockingCoroutine{Active}@") -->
<p>所以 在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/is-active.html" target="_blank" rel="noopener">CoroutineScope.isActive</a> 中的 <a href="">isActive</a> 只是 <code>coroutineContext[Job]!!.isActive</code> 的快捷方式</p>
<h3 id="协程的孩子"><a href="#协程的孩子" class="headerlink" title="协程的孩子"></a>协程的孩子</h3><p>当协程的 <a href="">coroutineContext</a> 被用来启动另一个协程时，新协程的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a> 就变成了父协程 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a> 的孩子，当父协程取消后所有它的孩子都会被递归的取消。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// launch a coroutine to process some kind of incoming request</span>
    <span class="token keyword">val</span> request <span class="token operator">=</span> launch <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// it spawns two other jobs, one with its separate context</span>
        <span class="token keyword">val</span> job1 <span class="token operator">=</span> launch <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"job1: I have my own context and execute independently!"</span><span class="token punctuation">)</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"job1: I am not affected by cancellation of the request"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// and the other inherits the parent context</span>
        <span class="token keyword">val</span> job2 <span class="token operator">=</span> <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"job2: I am a child of the request coroutine"</span><span class="token punctuation">)</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"job2: I will not execute this line if my parent request is cancelled"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// request completes when both its sub-jobs complete:</span>
        job1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        job2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
    request<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancel processing of the request</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// delay a second to see what happens</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: Who has survived request cancellation?"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-06.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>输出如下：</p>
<pre class=" language-text"><code class="language-text">job1: I have my own context and execute independently!
job2: I am a child of the request coroutine
job1: I am not affected by cancellation of the request
main: Who has survived request cancellation?
</code></pre>
<!--- TEST -->
<h3 id="组合上下文"><a href="#组合上下文" class="headerlink" title="组合上下文"></a>组合上下文</h3><p>协程的上下文可以使用 <code>+</code> 运算符组合。右边的上下文替换了左边上下文的相关条目，例如 父类协程的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a> 可以被继承，而它的调度器被替换：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// start a coroutine to process some kind of incoming request</span>
    <span class="token keyword">val</span> request <span class="token operator">=</span> <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// use the context of `runBlocking`</span>
        <span class="token comment" spellcheck="true">// spawns CPU-intensive child job in CommonPool !!! </span>
        <span class="token keyword">val</span> job <span class="token operator">=</span> <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext <span class="token operator">+</span> CommonPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"job: I am a child of the request coroutine, but with a different dispatcher"</span><span class="token punctuation">)</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"job: I will not execute this line if my parent request is cancelled"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// request completes when its sub-job completes</span>
    <span class="token punctuation">}</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
    request<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancel processing of the request</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// delay a second to see what happens</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main: Who has survived request cancellation?"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-07.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>该代码的预期结果是：</p>
<pre class=" language-text"><code class="language-text">job: I am a child of the request coroutine, but with a different dispatcher
main: Who has survived request cancellation?
</code></pre>
<!--- TEST -->
<h3 id="父类的责任"><a href="#父类的责任" class="headerlink" title="父类的责任"></a>父类的责任</h3><p>父类总是等待所有它的孩子的完成。父类不必显示地跟踪它启动的所有孩子而且也不必在最后使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/join.html" target="_blank" rel="noopener">Job.join</a> 来等待他们：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// launch a coroutine to process some kind of incoming request</span>
    <span class="token keyword">val</span> request <span class="token operator">=</span> launch <span class="token punctuation">{</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">-></span> <span class="token comment" spellcheck="true">// launch a few children jobs</span>
            <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
                <span class="token function">delay</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">200L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// variable delay 200ms, 400ms, 600ms</span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coroutine <span class="token interpolation variable">$i</span> is done"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"request: I'm done and I don't explicitly join my children that are still active"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    request<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// wait for completion of the request, including all its children</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Now processing of the request is complete"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-08.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>结果将是：</p>
<pre class=" language-text"><code class="language-text">request: I'm done and I don't explicitly join my children that are still active
Coroutine 0 is done
Coroutine 1 is done
Coroutine 2 is done
Now processing of the request is complete
</code></pre>
<!--- TEST -->
<h3 id="为调试命名协程"><a href="#为调试命名协程" class="headerlink" title="为调试命名协程"></a>为调试命名协程</h3><p>当协程日志频繁时自动分配的id很好，你只需要将来自相同协程的日志记录关联起来。然而当协程被绑定到特定请求的处理或做一些特定的后台任务时，最好将其显示地命名用于调试目的。<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-name/index.html" target="_blank" rel="noopener">CoroutineName</a> 上下文元素的功能与线程名称相同。当调试模式打开时正在执行的这个协程会显示在线程名称中。</p>
<p>下面的例子演示了这个概念</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"[<span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>] <span class="token interpolation variable">$msg</span>"</span><span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">runBlocking</span><span class="token punctuation">(</span><span class="token function">CoroutineName</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Started main coroutine"</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// run two background value computations</span>
    <span class="token keyword">val</span> v1 <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span><span class="token function">CoroutineName</span><span class="token punctuation">(</span><span class="token string">"v1coroutine"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Computing v1"</span><span class="token punctuation">)</span>
        <span class="token number">252</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">val</span> v2 <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span><span class="token function">CoroutineName</span><span class="token punctuation">(</span><span class="token string">"v2coroutine"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Computing v2"</span><span class="token punctuation">)</span>
        <span class="token number">6</span>
    <span class="token punctuation">}</span>
    <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"The answer for v1 / v2 = <span class="token interpolation"><span class="token delimiter variable">${</span>v1<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v2<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-09.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>类似地配置 JVM 选项 <code>-Dkotlinx.coroutines.debug</code> 将会产生下面输出</p>
<pre class=" language-text"><code class="language-text">[main @main#1] Started main coroutine
[ForkJoinPool.commonPool-worker-1 @v1coroutine#2] Computing v1
[ForkJoinPool.commonPool-worker-2 @v2coroutine#3] Computing v2
[main @main#1] The answer for v1 / v2 = 42
</code></pre>
<!--- TEST FLEXIBLE_THREAD -->
<h3 id="工作的显式取消"><a href="#工作的显式取消" class="headerlink" title="工作的显式取消"></a>工作的显式取消</h3><p>让我们把对协程的<code>context</code>、<code>children</code>、和<code>job</code>的认知放在一起。假设我们的应用程序有一个具有生命周期的对象，但这个对象不是一个协程。比如，我们正在编写一个 Android 应用程序并在 Android 的 Activity 的上下文中启动了多种协程去执行获取、更新数据、动画等的异步操作。为了避免一些内存泄漏所有的这些协程必须在 Activity 销毁的时候取消。</p>
<p>我们可以通过创建一个绑定到我们 Activity 生命周期的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a> 实例对象来管理协程的生命周期。如下面例子展示的，为了方便起见，使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job.html" target="_blank" rel="noopener">Job()</a> 工厂函数来创建一个 <a href="">Job</a> 实例对象而不是使用 <code>launch(coroutineContext + job)</code> 表达式创建。我们可以编写 <code>launch(coroutineContext, parent = job)</code>来明确表示正在使用父类 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a> 的事实。</p>
<p>现在，一个单独的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/cancel.html" target="_blank" rel="noopener">Job.cancel</a> 的调用就可以取消所有我们启动的孩子 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a>。此外 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/join.html" target="_blank" rel="noopener">Job.join</a> 等待所有的孩子工作的完成，所以我们可以在这个例子中使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/cancel-and-join.html" target="_blank" rel="noopener">cancelAndJoin</a>:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> job <span class="token operator">=</span> <span class="token function">Job</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// create a job object to manage our lifecycle</span>
    <span class="token comment" spellcheck="true">// now launch ten coroutines for a demo, each working for a different time</span>
    <span class="token keyword">val</span> coroutines <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">-></span>
        <span class="token comment" spellcheck="true">// they are all children of our job object</span>
        <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">,</span> parent <span class="token operator">=</span> job<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// we use the context of main runBlocking thread, but with our parent job</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">200L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// variable delay 200ms, 400ms, ... etc</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coroutine <span class="token interpolation variable">$i</span> is done"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Launched <span class="token interpolation"><span class="token delimiter variable">${</span>coroutines<span class="token punctuation">.</span>size<span class="token delimiter variable">}</span></span> coroutines"</span><span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500L</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// delay for half a second</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cancelling the job!"</span><span class="token punctuation">)</span>
    job<span class="token punctuation">.</span><span class="token function">cancelAndJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancel all our coroutines and wait for all of them to complete</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 [这里] 得到完整的代码(<a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-10.kt" target="_blank" rel="noopener">https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-10.kt</a>)</p>
</blockquote>
<p>这个例子的输出：</p>
<pre class=" language-text"><code class="language-text">Launched 10 coroutines
Coroutine 0 is done
Coroutine 1 is done
Cancelling the job!
</code></pre>
<!--- TEST -->
<p>正如你看到的，只是前三个协程打印了信息，而其他的协程都被一个 <code>job.cancelAndJoin()</code> 调用取消了。因此在我们假设的 Android 应用程序中，我们需要做的就是在创建 Activity 时创建一个父类 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a> 并将其应用于子 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a> ，并在 Activity 销毁的时候取消它，我们不能在 Android 生命周期中 <code>join</code> 他们。因为他们是同步的。但是可以在构建后台服务以确保有界的资源使用时这种加入连接能力是有用的。 </p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-deferred/index.html" target="_blank" rel="noopener">Deferred</a> 延迟值提供一个方便的途径去传递协程间的单值。Channels 通道提供了一种传递值流的方法。</p>
<!--- INCLUDE .*/example-channel-([0-9]+).kt
import kotlinx.coroutines.experimental.channels.*
-->
<h3 id="通道基础"><a href="#通道基础" class="headerlink" title="通道基础"></a>通道基础</h3><p>[Channel] 在概念上非常类似于阻塞队列 <code>BlockingQueue</code>。一个关键的区别是 它有一个挂起的[send]而不是一个阻塞的 <code>put</code> 操作，一个挂起的 <a href="">receive</a> 而不是一个阻塞的 <code>take</code> 操作：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    launch <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// this might be heavy CPU-consuming computation or async logic, we'll just send five squares</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">)</span> channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// here we print five received integers:</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Done!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-01.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>输出的代码：</p>
<pre class=" language-text"><code class="language-text">1
4
9
16
25
Done!
</code></pre>
<!--- TEST -->
<h3 id="通道关闭和迭代"><a href="#通道关闭和迭代" class="headerlink" title="通道关闭和迭代"></a>通道关闭和迭代</h3><p>和队列不同，通道可以被关闭意味着没有更多的元素可以进来。在接收端使用一个常规的 <code>for</code> 循环来接收从通道中来的元素是很方便的。概念上，<a href="">close</a> 像是发送一个特殊的关闭凭证到通道。一旦接收到了这个关闭凭证迭代就会停止。所以可以保证在 <a href="">close</a> 调用之前发送的元素都可以被接收到:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    launch <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">)</span> channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span>
        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// we're done sending</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// here we print received values using `for` loop (until the channel is closed)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>y <span class="token keyword">in</span> channel<span class="token punctuation">)</span> <span class="token function">println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Done!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-02.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST 
1
4
9
16
25
Done!
-->
<h3 id="构建通道生产者"><a href="#构建通道生产者" class="headerlink" title="构建通道生产者"></a>构建通道生产者</h3><p>这种协程产生序列元素的模式是很常见的。它是在并发代码中经常看到的生产者-消费者模式的一部分。你可以将这样的生产者抽象为以通道为参数的函数，但这违背了必须从函数返回结果的常识。这里有一个名为 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/produce.html" target="_blank" rel="noopener">produce</a> 的协程构造器可以在生产者端很容易地做这件事,并且有一个扩展函数 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/consume-each.html" target="_blank" rel="noopener">consumeEach</a> 取代消费者端的 <code>for</code> 循环。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">produceSquares</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> squares <span class="token operator">=</span> <span class="token function">produceSquares</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    squares<span class="token punctuation">.</span><span class="token function">consumeEach</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Done!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-03.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST 
1
4
9
16
25
Done!
-->
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是协程产生的一个可能无限的值流。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">produceNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// infinite stream of integers starting from 1</span>
<span class="token punctuation">}</span>
</code></pre>
<p>另一个协程或一些协程正在消费这条值流，做一些处理并产生一些其它的结果。在下面的例子中，数字仅仅被平方：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">square</span><span class="token punctuation">(</span>numbers<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> numbers<span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>主函数启动并连接整个管道:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> numbers <span class="token operator">=</span> <span class="token function">produceNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// produces integers from 1 and on</span>
    <span class="token keyword">val</span> squares <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// squares integers</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token function">println</span><span class="token punctuation">(</span>squares<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// print first five</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Done!"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// we are done</span>
    squares<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// need to cancel these coroutines in a larger app</span>
    numbers<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-04.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST 
1
4
9
16
25
Done!
-->
<p>在这个示例应用程序中我们不必取消这些协程，因为协程是守护线程，但是在大的应用程序中我们需要在不再需要的使用去停止管道。另外我们可以像下面的例子中演示的那样，将管道协程作为主协程的孩子运行。</p>
<h3 id="素数与管道"><a href="#素数与管道" class="headerlink" title="素数与管道"></a>素数与管道</h3><p>让我们以管道为例来生成素数。我们以一个无穷数列开始，这次我们引入了一个显式的 <code>context</code> 参数，并将其传递给 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/produce.html" target="_blank" rel="noopener">produce</a> 构建器，以便调用方可以控制我们协程运行的位置。</p>
<!--- INCLUDE core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-05.kt  
import kotlin.coroutines.experimental.CoroutineContext
-->
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">numbersFrom</span><span class="token punctuation">(</span>context<span class="token operator">:</span> CoroutineContext<span class="token punctuation">,</span> start<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> start
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// infinite stream of integers from start</span>
<span class="token punctuation">}</span>
</code></pre>
<p>下面的管道阶段过滤一个输入数字流，移除掉所有能被给定素数整除的数字：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">filter</span><span class="token punctuation">(</span>context<span class="token operator">:</span> CoroutineContext<span class="token punctuation">,</span> numbers<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">,</span> prime<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> numbers<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> prime <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>现在我们启动一个以数字2开始的数字流来构建我们的管道，从当前的通道中拿出一个素数，并为每一个发现的素数启动一个新的管道阶段。</p>
<pre><code>numbersFrom(2) -&gt; filter(2) -&gt; filter(3) -&gt; filter(5) -&gt; filter(7) ...
</code></pre><p>下面的例子打印前十个素数，运行在主线程中的上下文中的整个管道，所有的协程作为主协程的孩子被启动，我们不必去维持一个显式的启动过的所有协程的列表，我们使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/kotlin.coroutines.experimental.-coroutine-context/cancel-children.html" target="_blank" rel="noopener">cancelChildren</a> 扩展函数去取消所有的子协程。 </p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> cur <span class="token operator">=</span> <span class="token function">numbersFrom</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">val</span> prime <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span>prime<span class="token punctuation">)</span>
        cur <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> prime<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancel all children to let main finish</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-05.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>输出代码：</p>
<pre class=" language-text"><code class="language-text">2
3
5
7
11
13
17
19
23
29
</code></pre>
<!--- TEST -->
<p>注意，你可以用标准库中的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/build-iterator.html" target="_blank" rel="noopener"><code>buildIterator</code></a> 构建器来构建相同的管道。用<code>buildIterator</code>替换<code>produce</code>，<br><code>yield</code>替换<code>send</code> ，<code>next</code> 替换 <code>receive</code>，<code>Iterator</code> 替换 <code>ReceiveChannel</code>，并删除上下文。你也不会再需要<code>runBlocking</code>。然而，使用上述通道的管道的好处是，如果在CommonPool上下文中运行，它实际上可以使用多个CPU内核。无论如何，这是一种非常不切实际的方法来找到素数。在实践中,管道涉及一些其他挂起调用(如异步调用远程服务),这些管道不能使用<code>buildSeqeunce</code>/ <code>buildIterator</code>,因为他们不允许任意挂起,与<code>produce</code>不同,这是完全异步的。</p>
<h3 id="扇出"><a href="#扇出" class="headerlink" title="扇出"></a>扇出</h3><p>多个协程可以从同一通道中接收数据并进行分配工作处理。让我们从一个定期产生数据（1秒产生10个数字）的生产者协程开始：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">produceNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">// start from 1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// produce next</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// wait 0.1s</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>接下来，我们可以有一些处理协程，在这个例子中，他们仅打印出他们接收到的数字：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">launchProcessor</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">,</span> channel<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> launch <span class="token punctuation">{</span>
    channel<span class="token punctuation">.</span><span class="token function">consumeEach</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Processor #<span class="token interpolation variable">$id</span> received <span class="token interpolation variable">$it</span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
</code></pre>
<p>现在我们启动5个处理器并让他们工作接近1秒的时间，看看会发生什么</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> producer <span class="token operator">=</span> <span class="token function">produceNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">launchProcessor</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> producer<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">950</span><span class="token punctuation">)</span>
    producer<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancel producer coroutine and thus kill them all</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-06.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>会产生类似于下面的输出，尽管接收每个特定整数的处理器id可能不同。</p>
<pre><code>Processor #2 received 1
Processor #4 received 2
Processor #0 received 3
Processor #1 received 4
Processor #3 received 5
Processor #2 received 6
Processor #4 received 7
Processor #0 received 8
Processor #1 received 9
Processor #3 received 10
</code></pre><!--- TEST lines.size == 10 && lines.withIndex().all { (i, line) -> line.startsWith("Processor #") && line.endsWith(" received ${i + 1}") } -->
<p>注意，取消生产者协程会关闭它的通道，因此，最终会终止处理器协程工作的通道上的迭代。</p>
<h3 id="扇入"><a href="#扇入" class="headerlink" title="扇入"></a>扇入</h3><p>多个协程可以发送数据到相同的通道，例如，我们有一个字符串通道以及一个挂起函数，它会以指定的延迟发送指定的字符串到这个通道：</p>
<pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">sendString</span><span class="token punctuation">(</span>channel<span class="token operator">:</span> SendChannel<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> s<span class="token operator">:</span> String<span class="token punctuation">,</span> time<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">delay</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span>
        channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>现在让我们来看一看会发生什么，如果我们启动了一对发送字符串的协程（在这个例子中我们启动他们在主线程的上下文中，作为主协程的孩子）</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">sendString</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token number">200L</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">sendString</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> <span class="token string">"BAR!"</span><span class="token punctuation">,</span> <span class="token number">500L</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// receive first six</span>
        <span class="token function">println</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancel all children to let main finish</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-07.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>输出:</p>
<pre class=" language-text"><code class="language-text">foo
foo
BAR!
foo
foo
BAR!
</code></pre>
<!--- TEST -->
<h3 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h3><p>到目前为止我们看到的都是没有缓冲区的通道。无缓冲的通道传递元素在发送者和接受者相遇时。如果先发射，那么它会挂起直到接收被调用，如果先接收，它会挂起直到发射被调用。 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-channel.html" target="_blank" rel="noopener">Channel()</a> 工厂函数和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/produce.html" target="_blank" rel="noopener">produce</a> 构造器都使用可选项 <code>capacity</code> 参数指定缓存大小，缓存允许发射者发送多个元素在通道被挂起前，类似于有特定容量的<code>BlockingQueue</code>，它会阻塞当缓存满的时候。</p>
<p>看一看下面代码的行为：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// create buffered channel</span>
    <span class="token keyword">val</span> sender <span class="token operator">=</span> <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// launch sender coroutine</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sending <span class="token interpolation variable">$it</span>"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// print before sending each element</span>
            channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// will suspend when buffer is full</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// don't receive anything... just wait....</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    sender<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancel sender coroutine</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-08.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>使用一个有4个容量的缓冲通道将会打印 “sending” 5次:</p>
<pre class=" language-text"><code class="language-text">Sending 0
Sending 1
Sending 2
Sending 3
Sending 4
</code></pre>
<!--- TEST -->
<p>前4个元素被添加进缓存中并且当尝试去发送第5个元素时发送器将会挂起。</p>
<h3 id="通道是公平的"><a href="#通道是公平的" class="headerlink" title="通道是公平的"></a>通道是公平的</h3><p>向通道发送和接收操作是公平的，因为他们遵循协程们间的调用顺序。他们是先进先出的顺序，例如 第一个调用 <code>receive</code> 的协程第一个得到元素、在下面的例子中，两个协程 “ping” 和 “pong” 从共享的 “table” 通道接收 “ball” 对象。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Ball</span><span class="token punctuation">(</span><span class="token keyword">var</span> hits<span class="token operator">:</span> Int<span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> table <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Ball<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// a shared table</span>
    <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">player</span><span class="token punctuation">(</span><span class="token string">"ping"</span><span class="token punctuation">,</span> table<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">player</span><span class="token punctuation">(</span><span class="token string">"pong"</span><span class="token punctuation">,</span> table<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    table<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">Ball</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// serve the ball</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// delay 1 second</span>
    coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// game over, cancel them</span>
<span class="token punctuation">}</span>

suspend <span class="token keyword">fun</span> <span class="token function">player</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">,</span> table<span class="token operator">:</span> Channel<span class="token operator">&lt;</span>Ball<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>ball <span class="token keyword">in</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// receive the ball in a loop</span>
        ball<span class="token punctuation">.</span>hits<span class="token operator">++</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation variable">$name</span> <span class="token interpolation variable">$ball</span>"</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// wait a bit</span>
        table<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>ball<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// send the ball back</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-09.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p><code>ping</code> 协程首先启动，所以它第一个接收到球。即使 <code>ping</code> 协程立刻把球收到并发出去，但是球会被 <code>pong</code>  协程收到，因为它已经在等待了。</p>
<pre class=" language-text"><code class="language-text">ping Ball(hits=1)
pong Ball(hits=2)
ping Ball(hits=3)
pong Ball(hits=4)
</code></pre>
<!--- TEST -->
<blockquote>
<p>注意，有时候通道可能会产生看起来不公平的执行，是因为正在使用的执行器的本性，详情请看<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/111" target="_blank" rel="noopener">this issue</a></p>
</blockquote>
<h2 id="共享可变状态和并发"><a href="#共享可变状态和并发" class="headerlink" title="共享可变状态和并发"></a>共享可变状态和并发</h2><p>可以使用如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-common-pool/index.html" target="_blank" rel="noopener">CommonPool</a> 的多线程分派器并发执行协程。它呈现了所有常见的并发问题。主要问题是访问共享可变状态的同步。在这一问题的解决方案中，与多线程世界的解决方案相似，但其他的解决方案是独特的。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们启动一千个协程，每个协程都做同样的动作一千次（总共执行一百万次）.我们测量它们的完成时间，以便进行进一步的比较：</p>
<!--- INCLUDE .*/example-sync-([0-9a-z]+).kt
import kotlin.coroutines.experimental.CoroutineContext
import kotlin.system.measureTimeMillis
-->
<!--- INCLUDE .*/example-sync-03.kt
import java.util.concurrent.atomic.AtomicInteger
-->
<!--- INCLUDE .*/example-sync-06.kt
import kotlinx.coroutines.experimental.sync.Mutex
import kotlinx.coroutines.experimental.sync.withLock
-->
<!--- INCLUDE .*/example-sync-07.kt
import kotlinx.coroutines.experimental.channels.*
-->
<pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">massiveRun</span><span class="token punctuation">(</span>context<span class="token operator">:</span> CoroutineContext<span class="token punctuation">,</span> action<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> n <span class="token operator">=</span> <span class="token number">1000</span> <span class="token comment" spellcheck="true">// number of coroutines to launch</span>
    <span class="token keyword">val</span> k <span class="token operator">=</span> <span class="token number">1000</span> <span class="token comment" spellcheck="true">// times an action is repeated by each coroutine</span>
    <span class="token keyword">val</span> time <span class="token operator">=</span> measureTimeMillis <span class="token punctuation">{</span>
        <span class="token keyword">val</span> jobs <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">launch</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">repeat</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        jobs<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Completed <span class="token interpolation"><span class="token delimiter variable">${</span>n <span class="token operator">*</span> k<span class="token delimiter variable">}</span></span> actions in <span class="token interpolation variable">$time</span> ms"</span><span class="token punctuation">)</span>    
<span class="token punctuation">}</span>
</code></pre>
<!--- INCLUDE .*/example-sync-([0-9a-z]+).kt -->
<p>我们使用多线程 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-common-pool/index.html" target="_blank" rel="noopener">CommonPool</a> 上下文启动一个增加一个共享可变变量的简单动作。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">massiveRun</span><span class="token punctuation">(</span>CommonPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Counter = <span class="token interpolation variable">$counter</span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-01.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST LINES_START
Completed 1000000 actions in
Counter =
-->
<p>最后会打印出什么？大概率不会打印出 “Counter = 1000000”，因为这一千个协程并发地增加 <code>counter</code>，他们之间没有同步数据状态。</p>
<blockquote>
<p>注意:如果您有一个具有2个或更少cpu的旧系统，那么您将始终看到1000000，因为在这个示例中，CommonPool只运行一个线程。为了重现这个问题，你需要做出以下改变:</p>
</blockquote>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> mtContext <span class="token operator">=</span> <span class="token function">newFixedThreadPoolContext</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"mtPool"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// explicitly define context with two threads</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">massiveRun</span><span class="token punctuation">(</span>mtContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// use it instead of CommonPool in this sample and below </span>
        counter<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Counter = <span class="token interpolation variable">$counter</span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-01b.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST LINES_START
Completed 1000000 actions in
Counter =
-->
<h3 id="Volatiles没有用"><a href="#Volatiles没有用" class="headerlink" title="Volatiles没有用"></a>Volatiles没有用</h3><p>有一种常见的误解，就是使变量 <code>volatile</code> 解决了并发问题。让我们试一试:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Volatile</span> <span class="token comment" spellcheck="true">// in Kotlin `volatile` is an annotation </span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">massiveRun</span><span class="token punctuation">(</span>CommonPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Counter = <span class="token interpolation variable">$counter</span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-02.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST LINES_START
Completed 1000000 actions in
Counter =
-->
<p>这段代码运行很慢，且在最后我们仍然得不到 “Counter = 1000000”，因为 volatile 变量保证线性化（这是 “atomic” 原子的技术术语）读取和写入变量，但是不支持更大量动作的原子性（我们这个例子中的）</p>
<h3 id="线程安全的数据结构"><a href="#线程安全的数据结构" class="headerlink" title="线程安全的数据结构"></a>线程安全的数据结构</h3><p>上诉问题的通用解决方案是使用线程安全的(即同步的、线性化的或原子的)数据结构，为需要在共享状态上执行的相应操作提供所有必要的同步。对于一个简单的计数器，我们可以使用 <code>AtomicInteger</code> 类，它具有原子性的<code>incrementAndGet</code>操作:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token function">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">massiveRun</span><span class="token punctuation">(</span>CommonPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Counter = <span class="token interpolation"><span class="token delimiter variable">${</span>counter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-03.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST ARBITRARY_TIME
Completed 1000000 actions in xxx ms
Counter = 1000000
-->
<p>这是解决这个问题的最快方法。它适用于普通计数器、集合、队列和其他标准数据结构和基本操作。但是，它不容易扩展到复杂的状态或复杂的操作，这些操作没有现成的线程安全实现。</p>
<h3 id="线程约束细粒度"><a href="#线程约束细粒度" class="headerlink" title="线程约束细粒度"></a>线程约束细粒度</h3><p>线程约束是一个解决共享可变状态问题的方法，所有访问特定共享状态仅限于单个线程。它通常用于UI应用程序，所有UI状态被限制到一个单独的事件调度/应用程序线程，在协程中很容易应用，就是使用一个单独的线程上下文：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> counterContext <span class="token operator">=</span> <span class="token function">newSingleThreadContext</span><span class="token punctuation">(</span><span class="token string">"CounterContext"</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">massiveRun</span><span class="token punctuation">(</span>CommonPool<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// run each coroutine in CommonPool</span>
        <span class="token function">withContext</span><span class="token punctuation">(</span>counterContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// but confine each increment to the single-threaded context</span>
            counter<span class="token operator">++</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Counter = <span class="token interpolation variable">$counter</span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-04.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST ARBITRARY_TIME
Completed 1000000 actions in xxx ms
Counter = 1000000
-->
<p>这段代码运行很慢，因为它的执行受线程颗粒度限制。每次的增加需要从多线程的 <code>CommonPool</code> 切换到使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-context.html" target="_blank" rel="noopener">withContext</a>块的单线程上下文中。 </p>
<h3 id="线程约束粗粒度"><a href="#线程约束粗粒度" class="headerlink" title="线程约束粗粒度"></a>线程约束粗粒度</h3><p>实际上，线程限制是在大的块中执行的，例如 状态更新业务逻辑的大片段只局限于单个线程。下面的例子是这样做的，在单线程的上下文中运行每个协程。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> counterContext <span class="token operator">=</span> <span class="token function">newSingleThreadContext</span><span class="token punctuation">(</span><span class="token string">"CounterContext"</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">massiveRun</span><span class="token punctuation">(</span>counterContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// run each coroutine in the single-threaded context</span>
        counter<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Counter = <span class="token interpolation variable">$counter</span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-05.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST ARBITRARY_TIME
Completed 1000000 actions in xxx ms
Counter = 1000000
-->
<p>现在运行起来快多了且产生正确的结果</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>互斥解决方案可以保护所有对关键部分的共享状态的修改从不并发执行。在阻塞的世界你通常会使用 <code>synchronized</code>或者 <code>ReentrantLock</code>。协程中的替代叫做<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.sync/-mutex/index.html" target="_blank" rel="noopener">Mutex</a>。它拥有 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.sync/-mutex/lock.html" target="_blank" rel="noopener">lock</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.sync/-mutex/unlock.html" target="_blank" rel="noopener">unlock</a>函数去限定关键的部分。关键的不同是 <code>Mutex.lock</code>是一个挂起函数，它并不阻塞线程。还有一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.sync/with-lock.html" target="_blank" rel="noopener">withLock</a> 扩展函数方便的代表 <code>mutex.lock(); try { ... } finally { mutex.unlock() }</code> 模式：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> mutex <span class="token operator">=</span> <span class="token function">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">massiveRun</span><span class="token punctuation">(</span>CommonPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mutex<span class="token punctuation">.</span><span class="token function">withLock</span> <span class="token punctuation">{</span>
            counter<span class="token operator">++</span>        
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Counter = <span class="token interpolation variable">$counter</span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-06.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST ARBITRARY_TIME
Completed 1000000 actions in xxx ms
Counter = 1000000
-->
<p>这个例子的锁定是细粒度的，所以它代价昂贵，然而,在你必须需要定期修改一些共享状态但是没有这个状态被限制的原始线程时这个方案是一种很好的选择。</p>
<h3 id="Actors行动者"><a href="#Actors行动者" class="headerlink" title="Actors行动者"></a>Actors行动者</h3><p>actor 是协程的一种组合，一种被封装进协程的受限的状态，一个与其它协程交流的通道。一个简单的 actor 可以写成一个函数，但是一个具有复杂状态的 actor 更适合写成一个类。</p>
<p>有一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/actor.html" target="_blank" rel="noopener">actor</a> 协程构建器可以方便地地组合 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/actor.html" target="_blank" rel="noopener">actor</a> 的邮箱通道以接收消息，并结合发送通道到一个结果工作对象中，这样就可以将单个引用作为它的句柄来执行。</p>
<p>使用actor的第一步是定义一个参与者将要处理的消息类。Kotlin的密封类 <a href="">sealed classes</a> 非常适合这个用途。我们用<code>IncCounter</code>消息来定义<code>CounterMsg</code>密封类，以增加计数器和<code>GetCounter</code>消息以获取其值。稍后需要发送响应。一个 <a href="">CompletableDeferred</a> 通信原语表示一个将来会被知道的值，在这里被用于这个目的。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Message types for counterActor</span>
<span class="token keyword">sealed</span> <span class="token keyword">class</span> CounterMsg
<span class="token keyword">object</span> IncCounter <span class="token operator">:</span> <span class="token function">CounterMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// one-way message to increment counter</span>
<span class="token keyword">class</span> <span class="token function">GetCounter</span><span class="token punctuation">(</span><span class="token keyword">val</span> response<span class="token operator">:</span> CompletableDeferred<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">CounterMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// a request with reply</span>
</code></pre>
<p>我们定义一个函数去使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/actor.html" target="_blank" rel="noopener">actor</a> 协程构建器启动一个 actor：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// This function launches a new counter actor</span>
<span class="token keyword">fun</span> <span class="token function">counterActor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> actor<span class="token operator">&lt;</span>CounterMsg<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">// actor state</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>msg <span class="token keyword">in</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// iterate over incoming messages</span>
        <span class="token keyword">when</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">is</span> IncCounter <span class="token operator">-></span> counter<span class="token operator">++</span>
            <span class="token keyword">is</span> GetCounter <span class="token operator">-></span> msg<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>主要代码很简单：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> counter <span class="token operator">=</span> <span class="token function">counterActor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// create the actor</span>
    <span class="token function">massiveRun</span><span class="token punctuation">(</span>CommonPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>IncCounter<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// send a message to get a counter value from an actor</span>
    <span class="token keyword">val</span> response <span class="token operator">=</span> CompletableDeferred<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    counter<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">GetCounter</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Counter = <span class="token interpolation"><span class="token delimiter variable">${</span>response<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    counter<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// shutdown the actor</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-07.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<!--- TEST ARBITRARY_TIME
Completed 1000000 actions in xxx ms
Counter = 1000000
-->
<p>actor 本身被执行的上下文是什么不重要。一个 actor 是一个顺序执行的协程，所以将状态限制到特定的协程可以作为一个解决共享可变状态问题的解决方案。Actor 比锁在负载下更有效，因为在这种情况下 actor 总是在工作且不需要切换到不同的上下文。</p>
<blockquote>
<p>注意，一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/actor.html" target="_blank" rel="noopener">actor</a> 协程构建器是一个二元的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/produce.html" target="_blank" rel="noopener">produce</a> 协程构建器。一个 actor 与它接收消息的通道相关联，而一个 [producer]则与它发送元素的通道相关联。</p>
</blockquote>
<h2 id="选择表达式"><a href="#选择表达式" class="headerlink" title="选择表达式"></a>选择表达式</h2><p>选择表达式可以同时等待多个挂起函数，并且 <em>select</em> 第一个可用的。</p>
<!--- INCLUDE .*/example-select-([0-9]+).kt
import kotlinx.coroutines.experimental.channels.*
import kotlinx.coroutines.experimental.selects.*
-->
<h3 id="从通道中选择"><a href="#从通道中选择" class="headerlink" title="从通道中选择"></a>从通道中选择</h3><p>我们有2个分别产生字符串<code>fizz</code> 和 <code>buzz</code>的生产者。<code>fizz</code> 生产者每300ms产生一个 “Fizz”：<br><!--- INCLUDE .*/example-select-01.kt
import kotlin.coroutines.experimental.CoroutineContext
--></p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">fizz</span><span class="token punctuation">(</span>context<span class="token operator">:</span> CoroutineContext<span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// sends "Fizz" every 300 ms</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span>
        <span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Fizz"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>buzz</code> 每500ms产生一个 “Buzz!”:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">buzz</span><span class="token punctuation">(</span>context<span class="token operator">:</span> CoroutineContext<span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// sends "Buzz!" every 500 ms</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
        <span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Buzz!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/receive.html" target="_blank" rel="noopener">receive</a> 挂起函数，我们可以从一个通道或另一个通道接收数据。但是  <a href="">select</a> 表达式允许我们同时使用它的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/on-receive.html" target="_blank" rel="noopener">onReceive</a> 子句来接收:</p>
<pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">selectFizzBuzz</span><span class="token punctuation">(</span>fizz<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> buzz<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    select<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// &lt;Unit> means that this select expression does not produce any result </span>
        fizz<span class="token punctuation">.</span><span class="token function">onReceive</span> <span class="token punctuation">{</span> value <span class="token operator">-></span>  <span class="token comment" spellcheck="true">// this is the first select clause</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fizz -> '<span class="token interpolation variable">$value</span>'"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        buzz<span class="token punctuation">.</span><span class="token function">onReceive</span> <span class="token punctuation">{</span> value <span class="token operator">-></span>  <span class="token comment" spellcheck="true">// this is the second select clause</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"buzz -> '<span class="token interpolation variable">$value</span>'"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>我们运行它七次：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> fizz <span class="token operator">=</span> <span class="token function">fizz</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span>
    <span class="token keyword">val</span> buzz <span class="token operator">=</span> <span class="token function">buzz</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">selectFizzBuzz</span><span class="token punctuation">(</span>fizz<span class="token punctuation">,</span> buzz<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancel fizz &amp; buzz coroutines    </span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-select-01.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>结果如下：</p>
<pre class=" language-text"><code class="language-text">fizz -> 'Fizz'
buzz -> 'Buzz!'
fizz -> 'Fizz'
fizz -> 'Fizz'
buzz -> 'Buzz!'
fizz -> 'Fizz'
buzz -> 'Buzz!'
</code></pre>
<!--- TEST -->
<h3 id="关闭选择"><a href="#关闭选择" class="headerlink" title="关闭选择"></a>关闭选择</h3><p>当通道关闭时，在 <code>select</code> 中 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/on-receive.html" target="_blank" rel="noopener">onReceive</a> 子句失败，相应的 <code>select</code> 抛出异常。当通道关闭时，我们可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/on-receive-or-null.html" target="_blank" rel="noopener">onReceiveOrNull</a> 子句执行特定的操作。下面的示例展示 <code>select</code> 是返回其所选子句的结果的表达式:</p>
<pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">selectAorB</span><span class="token punctuation">(</span>a<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> b<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token operator">=</span>
    select<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>
        a<span class="token punctuation">.</span><span class="token function">onReceiveOrNull</span> <span class="token punctuation">{</span> value <span class="token operator">-></span> 
            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
                <span class="token string">"Channel 'a' is closed"</span> 
            <span class="token keyword">else</span> 
                <span class="token string">"a -> '<span class="token interpolation variable">$value</span>'"</span>
        <span class="token punctuation">}</span>
        b<span class="token punctuation">.</span><span class="token function">onReceiveOrNull</span> <span class="token punctuation">{</span> value <span class="token operator">-></span> 
            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
                <span class="token string">"Channel 'b' is closed"</span>
            <span class="token keyword">else</span>    
                <span class="token string">"b -> '<span class="token interpolation variable">$value</span>'"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>我们使用通道<code>a</code>产生 “Hello” 4次，通道<code>b</code>产生 “World” 4次：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// we are using the context of the main thread in this example for predictability ... </span>
    <span class="token keyword">val</span> a <span class="token operator">=</span> produce<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Hello <span class="token interpolation variable">$it</span>"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">val</span> b <span class="token operator">=</span> produce<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"World <span class="token interpolation variable">$it</span>"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// print first eight results</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">selectAorB</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-select-02.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>结果非常有趣，我们来详细分析一下：</p>
<pre class=" language-text"><code class="language-text">a -> 'Hello 0'
a -> 'Hello 1'
b -> 'World 0'
a -> 'Hello 2'
a -> 'Hello 3'
b -> 'World 1'
Channel 'a' is closed
Channel 'a' is closed
</code></pre>
<!--- TEST -->
<p>有两个观察结果可以证明这一点</p>
<p>第一点，<code>select</code> 偏向于第一个子句，当多个子句同时可选时，第一个子句优先被选中。在这里，两个通道都在不断地产生字符串，所以“a”通道，作为<code>select</code>的第一个子句会获胜。然而由于我们使用的是无缓冲通道，因此“a”会不时地被挂起在它的 <a href="">send</a> 调用上，并给 “b” 一个发送的机会。<br>第二点，当通道已经关闭时，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/on-receive-or-null.html" target="_blank" rel="noopener">onReceiveOrNull</a> 会立即被选中。</p>
<h3 id="选择发送"><a href="#选择发送" class="headerlink" title="选择发送"></a>选择发送</h3><p>选择表达式有一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-send-channel/on-send.html" target="_blank" rel="noopener">onSend</a> 子句可以很好的结合选择的偏好性质来使用,让我们来写一个整数生产者的例子，当消费者在其主频道上无法跟上它的时候，将其值发送到<code>side</code> 频道：</p>
<!--- INCLUDE
import kotlin.coroutines.experimental.CoroutineContext
-->
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">produceNumbers</span><span class="token punctuation">(</span>context<span class="token operator">:</span> CoroutineContext<span class="token punctuation">,</span> side<span class="token operator">:</span> SendChannel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>num <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// produce 10 numbers from 1 to 10</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// every 100 ms</span>
        select<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token function">onSend</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// Send to the primary channel</span>
            side<span class="token punctuation">.</span><span class="token function">onSend</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// or to the side channel     </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>消费者将会非常缓慢，每个数字需要250毫秒的时间来处理:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> side <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// allocate side channel</span>
    <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// this is a very fast consumer for the side channel</span>
        side<span class="token punctuation">.</span><span class="token function">consumeEach</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Side channel has <span class="token interpolation variable">$it</span>"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">produceNumbers</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">,</span> side<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">consumeEach</span> <span class="token punctuation">{</span> 
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consuming <span class="token interpolation variable">$it</span>"</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// let us digest the consumed number properly, do not hurry</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Done consuming"</span><span class="token punctuation">)</span>
    coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-select-03.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>我们来看看会发生什么：</p>
<pre class=" language-text"><code class="language-text">Consuming 1
Side channel has 2
Side channel has 3
Consuming 4
Side channel has 5
Side channel has 6
Consuming 7
Side channel has 8
Side channel has 9
Consuming 10
Done consuming
</code></pre>
<!--- TEST -->
<h3 id="选择延迟值"><a href="#选择延迟值" class="headerlink" title="选择延迟值"></a>选择延迟值</h3><p>延迟值可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-deferred/on-await.html" target="_blank" rel="noopener">onAwait</a> 子句来被选择。我们启动一个在一个随机延迟后返回一个延迟的字符串值的异步函数</p>
<!--- INCLUDE .*/example-select-04.kt
import java.util.*
-->
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">asyncString</span><span class="token punctuation">(</span>time<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> async <span class="token punctuation">{</span>
    <span class="token function">delay</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token string">"Waited for <span class="token interpolation variable">$time</span> ms"</span>
<span class="token punctuation">}</span>
</code></pre>
<p>让我们以随机的延迟来启动12个上面的异步函数</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">asyncStringsList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> List<span class="token operator">&lt;</span>Deferred<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> random <span class="token operator">=</span> <span class="token function">Random</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">asyncString</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>现在，主函数等待第一个函数完成并计算仍然处于活动状态的递延值的数量。注意，我们在这里使用的<code>select</code>表达式事实上是Kotlin DSL，因此我们可以使用任意代码为它提供子句。在本例中，我们迭代了一个递延值列表，为每个递延值提供 onwait 子句。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">asyncStringsList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> result <span class="token operator">=</span> select<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">withIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> deferred<span class="token punctuation">)</span> <span class="token operator">-></span>
            deferred<span class="token punctuation">.</span><span class="token function">onAwait</span> <span class="token punctuation">{</span> answer <span class="token operator">-></span>
                <span class="token string">"Deferred <span class="token interpolation variable">$index</span> produced answer '<span class="token interpolation variable">$answer</span>'"</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token keyword">val</span> countActive <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">count</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>isActive <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation variable">$countActive</span> coroutines are still active"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-select-04.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>输出是：</p>
<pre class=" language-text"><code class="language-text">Deferred 4 produced answer 'Waited for 128 ms'
11 coroutines are still active
</code></pre>
<!--- TEST -->
<h3 id="切换延迟值的通道"><a href="#切换延迟值的通道" class="headerlink" title="切换延迟值的通道"></a>切换延迟值的通道</h3><p>让我们编写一个通道生成器函数，它使用延迟字符串值的通道，等待每个接收到的延迟值直到下一个递延值出现或通道关闭。这个示例将 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/on-receive-or-null.html" target="_blank" rel="noopener">onReceiveOrNull</a>和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-deferred/on-await.html" target="_blank" rel="noopener">onAwait</a> 子句放在同一个 <code>select</code> 中:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">switchMapDeferreds</span><span class="token punctuation">(</span>input<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Deferred<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> current <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// start with first received deferred value</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>isActive<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// loop while not cancelled/closed</span>
        <span class="token keyword">val</span> next <span class="token operator">=</span> select<span class="token operator">&lt;</span>Deferred<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token operator">?</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// return next deferred value from this select or null</span>
            input<span class="token punctuation">.</span><span class="token function">onReceiveOrNull</span> <span class="token punctuation">{</span> update <span class="token operator">-></span>
                update <span class="token comment" spellcheck="true">// replaces next value to wait</span>
            <span class="token punctuation">}</span>
            current<span class="token punctuation">.</span><span class="token function">onAwait</span> <span class="token punctuation">{</span> value <span class="token operator">-></span>  
                <span class="token function">send</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// send value that current deferred has produced</span>
                input<span class="token punctuation">.</span><span class="token function">receiveOrNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// and use the next deferred from the input channel</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Channel was closed"</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span> <span class="token comment" spellcheck="true">// out of loop</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            current <span class="token operator">=</span> next
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>为了测试它，我们将使用一个简单的异步函数，它在指定的时间后返回指定的字符串:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">asyncString</span><span class="token punctuation">(</span>str<span class="token operator">:</span> String<span class="token punctuation">,</span> time<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token operator">=</span> async <span class="token punctuation">{</span>
    <span class="token function">delay</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span>
    str
<span class="token punctuation">}</span>
</code></pre>
<p>主函数启动一个协程打印<code>switchMapDeferreds</code>的结果，并将一些测试数据发送给它:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> chan <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Deferred<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// the channel for test</span>
    <span class="token function">launch</span><span class="token punctuation">(</span>coroutineContext<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// launch printing coroutine</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>s <span class="token keyword">in</span> <span class="token function">switchMapDeferreds</span><span class="token punctuation">(</span>chan<span class="token punctuation">)</span><span class="token punctuation">)</span> 
            <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// print each received string</span>
    <span class="token punctuation">}</span>
    chan<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">asyncString</span><span class="token punctuation">(</span><span class="token string">"BEGIN"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// enough time for "BEGIN" to be produced</span>
    chan<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">asyncString</span><span class="token punctuation">(</span><span class="token string">"Slow"</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// not enough time to produce slow</span>
    chan<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">asyncString</span><span class="token punctuation">(</span><span class="token string">"Replace"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// give it time before the last one</span>
    chan<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">asyncString</span><span class="token punctuation">(</span><span class="token string">"END"</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// give it time to process</span>
    chan<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// close the channel ... </span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// and wait some time to let it finish</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>你可以从 <a href="https://github.com/ethanhua/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-select-05.kt" target="_blank" rel="noopener">这里</a> 得到完整的代码</p>
</blockquote>
<p>代码运行结果：</p>
<pre class=" language-text"><code class="language-text">BEGIN
Replace
END
Channel was closed
</code></pre>
<!--- TEST -->
<h2 id="进阶阅读"><a href="#进阶阅读" class="headerlink" title="进阶阅读"></a>进阶阅读</h2><ul>
<li><a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md" target="_blank" rel="noopener">Guide to UI programming with coroutines</a></li>
<li><a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md" target="_blank" rel="noopener">Guide to reactive streams with coroutines</a></li>
<li><a href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md" target="_blank" rel="noopener">Coroutines design document (KEEP)</a></li>
<li><a href="http://kotlin.github.io/kotlinx.coroutines" target="_blank" rel="noopener">Full kotlinx.coroutines API reference</a></li>
</ul>
<!--- MODULE kotlinx-coroutines-core -->
<!--- INDEX kotlinx.coroutines.experimental -->
<!--- INDEX kotlinx.coroutines.experimental.sync -->
<!--- INDEX kotlinx.coroutines.experimental.channels -->
<!--- INDEX kotlinx.coroutines.experimental.selects -->
<!--- END -->
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/03/20/briefpreference/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/01/20/kotlin-function-md/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.jpg" alt="Ethan Hua's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        65351871@qq.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/12/">十二月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/05/">五月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/04/">四月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/03/">三月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/02/">二月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/01/">一月 2018<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/12/">十二月 2017<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/11/">十一月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/10/">十月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/09/">九月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/07/">七月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/06/">六月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/05/">五月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/04/">四月 2017<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                <a class="sidebar_archives-link" href="/categories/Android/">Android<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/Arithmetic/">Arithmetic<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/JVM/">JVM<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/Jvm/">Jvm<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/RxJava-Android/">RxJava/Android<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/UI-Android/">UI/Android<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/架构组件-Android/">架构组件/Android<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/语言基础/">语言基础<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/进程通信-Linux/">进程通信/Linux<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/随笔/">随笔<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/音视频-Android/">音视频/Android<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
        <li>
            <a href="/archives">
                文章总数
                <span class="sidebar-badge">18</span>
            </a>
        </li>
        
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/ethanhua" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Ethanhua's blog
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import File -->


    <script>lsloader.load("js/lazyload.min.js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==")</script>
    <script>lsloader.load("js/js.min.js","/js/js.min.js?oAl/+lvaqTFV31JXTmbrNA==")</script>



    <script>lsloader.load("js/nprogress.js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==")</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Window Load-->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });
</script>

<!-- MathJax Load-->

<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Bing Background -->


<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.4.0 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
